"""
Generated by nlsc from examples/workflow_engine.nl
Module: workflow_engine
"""

from dataclasses import dataclass
from typing import Any, cast, Optional


@dataclass
class Priority:
    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError('value is required')


@dataclass
class TaskStatus:
    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError('value is required')


@dataclass
class WorkflowStatus:
    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError('value is required')


@dataclass
class User:
    id: str
    name: str
    email: str
    role: str
    capacity: float
    skills: list[str]

    def __post_init__(self):
        if not self.id:
            raise ValueError('id is required')
        if not self.name:
            raise ValueError('name is required')
        if not self.email:
            raise ValueError('email is required')
        if not self.role:
            raise ValueError('role is required')


@dataclass
class TimeEstimate:
    optimistic: float
    realistic: float
    pessimistic: float

    def __post_init__(self):
        if not (self.optimistic <= self.realistic):
            raise ValueError("Invariant violated: optimistic <= realistic")
        if not (self.realistic <= self.pessimistic):
            raise ValueError("Invariant violated: realistic <= pessimistic")
        if not (self.pessimistic > 0):
            raise ValueError("Invariant violated: pessimistic > 0")


@dataclass
class Task:
    id: str
    title: str
    description: str
    status: TaskStatus
    priority: Priority
    created_at: float
    actual_hours: float
    dependencies: list[str]
    tags: list[str]
    assignee_id: Optional[str] = None
    due_date: Optional[float] = None
    completed_at: Optional[float] = None
    estimate: Optional[TimeEstimate] = None

    def __post_init__(self):
        if not self.id:
            raise ValueError('id is required')
        if not self.title:
            raise ValueError('title is required')
        if not self.status:
            raise ValueError('status is required')
        if not self.priority:
            raise ValueError('priority is required')
        if not self.created_at:
            raise ValueError('created_at is required')
        if not (self.actual_hours >= 0):
            raise ValueError("Invariant violated: actual_hours >= 0")


@dataclass
class Workflow:
    id: str
    name: str
    description: str
    status: WorkflowStatus
    owner_id: str
    tasks: list[Task]
    created_at: float
    started_at: Optional[float] = None
    completed_at: Optional[float] = None
    deadline: Optional[float] = None

    def __post_init__(self):
        if not self.id:
            raise ValueError('id is required')
        if not self.name:
            raise ValueError('name is required')
        if not self.status:
            raise ValueError('status is required')
        if not self.owner_id:
            raise ValueError('owner_id is required')
        if not self.created_at:
            raise ValueError('created_at is required')


@dataclass
class Assignment:
    task_id: str
    user_id: str
    assigned_at: float
    assigned_by: str
    notes: Optional[str] = None

    def __post_init__(self):
        if not self.task_id:
            raise ValueError('task_id is required')
        if not self.user_id:
            raise ValueError('user_id is required')
        if not self.assigned_at:
            raise ValueError('assigned_at is required')
        if not self.assigned_by:
            raise ValueError('assigned_by is required')


@dataclass
class WorkloadReport:
    user_id: str
    total_tasks: float
    pending_tasks: float
    in_progress_tasks: float
    completed_tasks: float
    total_estimated_hours: float
    utilization_percent: float

    def __post_init__(self):
        if not self.user_id:
            raise ValueError('user_id is required')
        if not (self.utilization_percent >= 0):
            raise ValueError("Invariant violated: utilization_percent >= 0")
        if not (self.utilization_percent <= 100):
            raise ValueError("Invariant violated: utilization_percent <= 100")


@dataclass
class WorkflowMetrics:
    workflow_id: str
    total_tasks: float
    completed_tasks: float
    blocked_tasks: float
    completion_percent: float
    is_on_track: bool
    critical_path_length: float
    estimated_completion_date: Optional[float] = None

    def __post_init__(self):
        if not self.workflow_id:
            raise ValueError('workflow_id is required')


@dataclass
class StatusCounts:
    pending: float
    in_progress: float
    blocked: float
    completed: float
    cancelled: float


@dataclass
class PriorityCounts:
    critical: float
    high: float
    medium: float
    low: float


@dataclass
class ReassignmentSuggestion:
    task_id: str
    from_user_id: str
    to_user_id: str
    reason: str

    def __post_init__(self):
        if not self.task_id:
            raise ValueError('task_id is required')
        if not self.from_user_id:
            raise ValueError('from_user_id is required')
        if not self.to_user_id:
            raise ValueError('to_user_id is required')


def priority_to_weight(priority: Priority) -> Any:
    """
    Convert priority to numeric weight for sorting.

    Args:
        priority: Priority

    Returns:
        {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
    """
    # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
    return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)


def compare_priorities(a: Priority, b: Priority) -> Any:
    """
    Compare two priorities, returning -1, 0, or 1.

    Args:
        a: Priority
        b: Priority

    Returns:
        (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
    """
    # Get weight of a -> weight_a
    # Get weight of b -> weight_b
    # Calculate difference -> diff
    return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))


def get_highest_priority(tasks: list[Task]) -> Any:
    """
    Get the highest priority from a list of tasks.

    Args:
        tasks: list of Task

    Returns:
        max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
    """
    if not (len(tasks) > 0):
        raise ValueError('Cannot get priority from empty list')
    # Extract priorities from all tasks -> priorities
    # Find maximum by weight -> highest
    return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority


def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
    """
    Calculate PERT estimate using formula (O + 4M + P) / 6.

    Args:
        estimate: TimeEstimate

    Returns:
        (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
    """
    if not (estimate.optimistic <= estimate.realistic):
        raise ValueError('Optimistic must be <= realistic')
    if not (estimate.realistic <= estimate.pessimistic):
        raise ValueError('Realistic must be <= pessimistic')
    # Apply PERT formula -> pert
    return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6


def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
    """
    Calculate variance in time estimate for risk assessment.

    Args:
        estimate: TimeEstimate

    Returns:
        ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
    """
    # Calculate range -> range_val
    # Divide by 6 and square -> variance
    return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2


def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
    """
    Calculate standard deviation of time estimate.

    Args:
        estimate: TimeEstimate

    Returns:
        calculate_estimate_variance(estimate) ** 0.5
    """
    # Calculate variance -> var
    # Take square root -> std_dev
    return calculate_estimate_variance(estimate) ** 0.5


def sum_estimates(estimates: list[TimeEstimate]) -> Any:
    """
    Sum multiple time estimates into one combined estimate.

    Args:
        estimates: list of TimeEstimate

    Returns:
        TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
    """
    if not (len(estimates) > 0):
        raise ValueError('Cannot sum empty list of estimates')
    # Sum all optimistic values -> total_opt
    # Sum all realistic values -> total_real
    # Sum all pessimistic values -> total_pess
    return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))


def average_estimate(estimates: list[TimeEstimate]) -> Any:
    """
    Calculate average of multiple time estimates.

    Args:
        estimates: list of TimeEstimate

    Returns:
        TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
    """
    if not (len(estimates) > 0):
        raise ValueError('Cannot average empty list')
    # Sum all estimates -> total
    # Divide each component by count -> avg
    return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))


def is_task_actionable(task: Task) -> Any:
    """
    Check if a task can be worked on (not blocked or completed).

    Args:
        task: Task

    Returns:
        task.status.value in ["pending", "in_progress"]
    """
    # Check status is pending or in_progress -> actionable
    return task.status.value in ["pending", "in_progress"]


def is_task_terminal(task: Task) -> Any:
    """
    Check if a task is in a terminal state.

    Args:
        task: Task

    Returns:
        task.status.value in ["completed", "cancelled"]
    """
    return task.status.value in ["completed", "cancelled"]


def is_task_blocked(task: Task) -> Any:
    """
    Check if a task has blocked status.

    Args:
        task: Task

    Returns:
        task.status.value == "blocked"
    """
    return task.status.value == "blocked"


def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
    """
    Count tasks matching a specific status.

    Args:
        tasks: list of Task
        status_value: string

    Returns:
        len([t for t in tasks if t.status.value == status_value])
    """
    # Filter tasks to matching status -> matching
    # Count matching tasks -> count
    return len([t for t in tasks if t.status.value == status_value])


def get_status_counts(tasks: list[Task]) -> Any:
    """
    Get counts of tasks by each status.

    Args:
        tasks: list of Task

    Returns:
        StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
    """
    # Count pending tasks -> pending
    # Count in_progress tasks -> in_progress
    # Count blocked tasks -> blocked
    # Count completed tasks -> completed
    # Count cancelled tasks -> cancelled
    return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))


def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
    """
    Find a task by its ID.

    Args:
        tasks: list of Task
        task_id: string

    Returns:
        next((t for t in tasks if t.id == task_id), None)
    """
    # Search for task with matching ID -> found
    return next((t for t in tasks if t.id == task_id), None)


def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
    """
    Get list of incomplete tasks that block a given task.

    Args:
        task: Task
        all_tasks: list of Task

    Returns:
        [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
    """
    # Get task IDs from dependencies -> dep_ids
    # Find tasks matching those IDs -> deps
    # Filter to non-terminal tasks -> blocking
    return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]


def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
    """
    Check if a task is blocked by incomplete dependencies.

    Args:
        task: Task
        all_tasks: list of Task

    Returns:
        len(get_blocking_tasks(task, all_tasks)) > 0
    """
    # Get blocking tasks -> blockers
    # Check if any blockers exist -> blocked
    return len(get_blocking_tasks(task, all_tasks)) > 0


def get_ready_tasks(tasks: list[Task]) -> Any:
    """
    Get all tasks that are ready to be worked on.

    Args:
        tasks: list of Task

    Returns:
        [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
    """
    # Filter to actionable tasks -> actionable
    # Filter to those not blocked -> ready
    return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]


def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
    """
    Calculate the maximum dependency chain depth for a task.

    Args:
        task: Task
        all_tasks: list of Task

    Returns:
        1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
    """
    # Get direct dependencies -> deps
    # Recursively calculate depth of each -> depths
    # Return max depth plus 1 -> total_depth
    return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)


def detect_circular_dependencies(tasks: list[Task]) -> Any:
    """
    Detect if there are circular dependencies in task list.

    Args:
        tasks: list of Task

    Returns:
        any(t.id in [d for d in t.dependencies] for t in tasks)
    """
    # Build adjacency list -> adj
    # Track visited and recursion stack -> visited, rec_stack
    # DFS from each unvisited node -> has_cycle
    return any(t.id in [d for d in t.dependencies] for t in tasks)


def topological_sort_tasks(tasks: list[Task]) -> Any:
    """
    Sort tasks by dependency order.

    Args:
        tasks: list of Task

    Returns:
        sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
    """
    if not (not detect_circular_dependencies(tasks)):
        raise ValueError('Circular dependency detected')
    # Build dependency graph -> graph
    # Find tasks with no dependencies -> roots
    # Process queue, adding tasks when deps satisfied -> sorted_list
    return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))


def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
    """
    Create a new assignment record.

    Args:
        task_id: string
        user_id: string
        assigner_id: string
        timestamp: number
        notes: string

    Returns:
        Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
    """
    # Build assignment record -> assignment
    return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")


def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
    """
    Assign a task to a user.

    Args:
        task: Task
        user: User
        assigner_id: string
        timestamp: number

    Returns:
        (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
    """
    if not (is_task_actionable(task)):
        raise ValueError('Cannot assign terminal task')
    if not (user.capacity > 0):
        raise ValueError('User has no available capacity')
    # Create assignment record -> assignment
    # Update task with assignee -> updated_task
    return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))


def unassign_task(task: Task) -> Any:
    """
    Remove assignment from a task.

    Args:
        task: Task

    Returns:
        Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
    """
    if not (task.assignee_id != None):
        raise ValueError('Task is not assigned')
    # Clear assignee_id from task -> updated
    return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)


def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
    """
    Reassign a task from one user to another.

    Args:
        task: Task
        new_user: User
        assigner_id: string
        timestamp: number

    Returns:
        assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
    """
    # Unassign current user -> unassigned
    # Assign to new user -> reassigned
    return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)


def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
    """
    Get all tasks assigned to a user.

    Args:
        tasks: list of Task
        user_id: string

    Returns:
        [t for t in tasks if t.assignee_id == user_id]
    """
    # Filter tasks to user -> user_tasks
    return [t for t in tasks if t.assignee_id == user_id]


def calculate_task_hours(task: Task) -> Any:
    """
    Calculate estimated hours for a single task.

    Args:
        task: Task

    Returns:
        calculate_pert_estimate(task.estimate) if task.estimate else 8.0
    """
    # Check if task has estimate -> has_est
    # Calculate PERT if has estimate, else default -> hours
    return calculate_pert_estimate(task.estimate) if task.estimate else 8.0


def calculate_total_hours(tasks: list[Task]) -> Any:
    """
    Calculate total estimated hours for a list of tasks.

    Args:
        tasks: list of Task

    Returns:
        sum(calculate_task_hours(t) for t in tasks)
    """
    # Calculate hours for each task -> hours_list
    # Sum all hours -> total
    return sum(calculate_task_hours(t) for t in tasks)


def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
    """
    Calculate workload report for a user.

    Args:
        user: User
        tasks: list of Task

    Returns:
        WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
    """
    # Filter tasks assigned to user -> user_tasks
    # Count by status -> counts
    # Sum estimates for incomplete tasks -> estimated_hours
    # Calculate utilization -> util_percent
    return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))


def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
    """
    Calculate combined workload for a team.

    Args:
        users: list of User
        tasks: list of Task

    Returns:
        WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
    """
    # Calculate workload for each user -> workloads
    # Aggregate totals -> team_totals
    return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))


def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
    """
    Find user with lowest current workload.

    Args:
        users: list of User
        tasks: list of Task

    Returns:
        min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
    """
    if not (len(users) > 0):
        raise ValueError('No users provided')
    # Calculate workload for each user -> workloads
    # Find minimum utilization -> min_load
    # Return user with minimum -> least_loaded
    return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)


def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
    """
    Find user with highest current workload.

    Args:
        users: list of User
        tasks: list of Task

    Returns:
        max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
    """
    if not (len(users) > 0):
        raise ValueError('No users provided')
    # Calculate workload for each user -> workloads
    # Find maximum utilization -> max_load
    # Return user with maximum -> most_loaded
    return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)


def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
    """
    Find users whose utilization exceeds threshold.

    Args:
        users: list of User
        tasks: list of Task
        threshold: number

    Returns:
        [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
    """
    # Calculate workload for each user -> workloads
    # Filter to those over threshold -> overloaded
    return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]


def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
    """
    Suggest task reassignments to balance workload.

    Args:
        users: list of User
        tasks: list of Task
        threshold: number

    Returns:
        [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
    """
    # Calculate workloads for all users -> workloads
    # Find overloaded and underloaded users -> over, under
    # Generate reassignment suggestions -> suggestions
    return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]


def calculate_workflow_progress(workflow: Workflow) -> Any:
    """
    Calculate completion percentage of a workflow.

    Args:
        workflow: Workflow

    Returns:
        len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
    """
    if not (len(workflow.tasks) > 0):
        raise ValueError('Workflow has no tasks')
    # Count completed tasks -> completed
    # Count total tasks -> total
    # Calculate percentage -> percent
    return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100


def calculate_remaining_work(tasks: list[Task]) -> Any:
    """
    Calculate total remaining work in hours.

    Args:
        tasks: list of Task

    Returns:
        calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
    """
    # Filter to incomplete tasks -> incomplete
    # Sum PERT estimates -> total_hours
    return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])


def calculate_completed_work(tasks: list[Task]) -> Any:
    """
    Calculate total completed work in hours.

    Args:
        tasks: list of Task

    Returns:
        sum(t.actual_hours for t in tasks if t.status.value == "completed")
    """
    # Filter to completed tasks -> completed
    # Sum actual hours -> total_hours
    return sum(t.actual_hours for t in tasks if t.status.value == "completed")


def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
    """
    Calculate team velocity in hours per day.

    Args:
        tasks: list of Task
        start_time: number
        end_time: number

    Returns:
        calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
    """
    if not (end_time > start_time):
        raise ValueError('End time must be after start time')
    # Calculate completed work in period -> completed_hours
    # Calculate days elapsed -> days
    # Divide hours by days -> velocity
    return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)


def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
    """
    Estimate when workflow will complete.

    Args:
        workflow: Workflow
        current_time: number
        velocity_hours_per_day: number

    Returns:
        current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
    """
    if not (velocity_hours_per_day > 0):
        raise ValueError('Velocity must be positive')
    # Calculate remaining work -> remaining_hours
    # Calculate days needed -> days_needed
    # Add to current time -> completion_date
    return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400


def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
    """
    Check if workflow is on track to meet deadline.

    Args:
        workflow: Workflow
        current_time: number
        velocity_hours_per_day: number

    Returns:
        workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
    """
    # Estimate completion date -> est_completion
    # Compare to deadline -> on_track
    return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline


def calculate_critical_path_length(tasks: list[Task]) -> Any:
    """
    Calculate the length of the critical path in hours.

    Args:
        tasks: list of Task

    Returns:
        max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
    """
    # Sort tasks topologically -> sorted_tasks
    # Calculate longest path through graph -> critical_path
    # Sum estimates along path -> total_hours
    return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)


def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
    """
    Calculate comprehensive metrics for a workflow.

    Args:
        workflow: Workflow
        current_time: number
        velocity_hours_per_day: number

    Returns:
        WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
    """
    # Count tasks by status -> counts
    # Calculate progress percentage -> progress
    # Estimate completion date -> est_completion
    # Determine if on track -> on_track
    # Calculate critical path -> critical_length
    return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))


def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
    """
    Create a new workflow in draft status.

    Args:
        id: string
        name: string
        owner_id: string
        timestamp: number

    Returns:
        Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
    """
    # Create workflow with draft status -> workflow
    return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)


def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
    """
    Add a task to a workflow.

    Args:
        workflow: Workflow
        task: Task

    Returns:
        Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
    """
    if not (workflow.status.value == "draft"):
        raise ValueError('Can only add tasks to draft workflows')
    # Append task to workflow tasks -> updated
    return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)


def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
    """
    Remove a task from a workflow.

    Args:
        workflow: Workflow
        task_id: string

    Returns:
        Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
    """
    if not (workflow.status.value == "draft"):
        raise ValueError('Can only remove tasks from draft workflows')
    # Filter out task with ID -> updated
    return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)


def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
    """
    Activate a draft workflow.

    Args:
        workflow: Workflow
        timestamp: number

    Returns:
        Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
    """
    if not (workflow.status.value == "draft"):
        raise ValueError('Can only activate draft workflows')
    if not (len(workflow.tasks) > 0):
        raise ValueError('Cannot activate empty workflow')
    if not (not detect_circular_dependencies(workflow.tasks)):
        raise ValueError('Workflow has circular dependencies')
    # Update status to active -> updated
    # Set started_at timestamp -> final
    return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)


def pause_workflow(workflow: Workflow) -> Any:
    """
    Pause an active workflow.

    Args:
        workflow: Workflow

    Returns:
        Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
    """
    if not (workflow.status.value == "active"):
        raise ValueError('Can only pause active workflows')
    # Update status to paused -> updated
    return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)


def resume_workflow(workflow: Workflow) -> Any:
    """
    Resume a paused workflow.

    Args:
        workflow: Workflow

    Returns:
        Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
    """
    if not (workflow.status.value == "paused"):
        raise ValueError('Can only resume paused workflows')
    # Update status to active -> updated
    return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)


def all_tasks_terminal(tasks: list[Task]) -> Any:
    """
    Check if all tasks in a list are terminal.

    Args:
        tasks: list of Task

    Returns:
        all(is_task_terminal(t) for t in tasks)
    """
    # Check each task is terminal -> all_done
    return all(is_task_terminal(t) for t in tasks)


def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
    """
    Mark a workflow as completed.

    Args:
        workflow: Workflow
        timestamp: number

    Returns:
        Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
    """
    if not (workflow.status.value == "active"):
        raise ValueError('Can only complete active workflows')
    if not (all_tasks_terminal(workflow.tasks)):
        raise ValueError('Cannot complete workflow with pending tasks')
    # Update status to completed -> updated
    # Set completed_at timestamp -> final
    return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)


def archive_workflow(workflow: Workflow) -> Any:
    """
    Archive a completed workflow.

    Args:
        workflow: Workflow

    Returns:
        Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
    """
    if not (workflow.status.value == "completed"):
        raise ValueError('Can only archive completed workflows')
    # Update status to archived -> updated
    return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)


def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
    """
    Filter tasks to those matching a status.

    Args:
        tasks: list of Task
        status: TaskStatus

    Returns:
        [t for t in tasks if t.status.value == status.value]
    """
    return [t for t in tasks if t.status.value == status.value]


def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
    """
    Filter tasks to those matching a priority.

    Args:
        tasks: list of Task
        priority: Priority

    Returns:
        [t for t in tasks if t.priority.value == priority.value]
    """
    return [t for t in tasks if t.priority.value == priority.value]


def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
    """
    Filter tasks to those assigned to a user.

    Args:
        tasks: list of Task
        user_id: string

    Returns:
        [t for t in tasks if t.assignee_id == user_id]
    """
    return [t for t in tasks if t.assignee_id == user_id]


def filter_unassigned_tasks(tasks: list[Task]) -> Any:
    """
    Filter to tasks with no assignee.

    Args:
        tasks: list of Task

    Returns:
        [t for t in tasks if t.assignee_id is None]
    """
    # Filter to tasks where assignee_id is None -> unassigned
    return [t for t in tasks if t.assignee_id is None]


def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
    """
    Filter tasks that are past their due date.

    Args:
        tasks: list of Task
        current_time: number

    Returns:
        [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
    """
    # Filter to tasks with due_date set -> with_due
    # Filter to non-terminal past due -> overdue
    return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]


def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
    """
    Filter tasks due within a time window.

    Args:
        tasks: list of Task
        current_time: number
        window_hours: number

    Returns:
        [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
    """
    # Calculate deadline threshold -> threshold
    # Filter tasks due before threshold -> due_soon
    return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]


def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
    """
    Find tasks that have a specific tag.

    Args:
        tasks: list of Task
        tag: string

    Returns:
        [t for t in tasks if tag in t.tags]
    """
    return [t for t in tasks if tag in t.tags]


def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
    """
    Find tasks with title containing search term.

    Args:
        tasks: list of Task
        search_term: string

    Returns:
        [t for t in tasks if search_term.lower() in t.title.lower()]
    """
    # Filter tasks where title contains term -> matching
    return [t for t in tasks if search_term.lower() in t.title.lower()]


def sort_tasks_by_priority(tasks: list[Task]) -> Any:
    """
    Sort tasks by priority highest first.

    Args:
        tasks: list of Task

    Returns:
        sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
    """
    # Sort using priority weight as key -> sorted_tasks
    return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)


def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
    """
    Sort tasks by due date earliest first.

    Args:
        tasks: list of Task

    Returns:
        sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
    """
    # Separate tasks with and without due dates -> with_due, no_due
    # Sort tasks with due dates -> sorted_due
    # Append tasks without due dates -> combined
    return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]


def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
    """
    Sort tasks by creation date oldest first.

    Args:
        tasks: list of Task

    Returns:
        sorted(tasks, key=lambda t: t.created_at)
    """
    # Sort by created_at ascending -> sorted_tasks
    return sorted(tasks, key=lambda t: t.created_at)


def generate_status_summary(tasks: list[Task]) -> Any:
    """
    Generate a summary of task counts by status.

    Args:
        tasks: list of Task

    Returns:
        get_status_counts(tasks)
    """
    # Get status counts -> counts
    return get_status_counts(tasks)


def generate_priority_summary(tasks: list[Task]) -> Any:
    """
    Generate a summary of task counts by priority.

    Args:
        tasks: list of Task

    Returns:
        PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
    """
    # Count critical tasks -> critical
    # Count high tasks -> high
    # Count medium tasks -> medium
    # Count low tasks -> low
    return PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))


def calculate_average_completion_time(tasks: list[Task]) -> Any:
    """
    Calculate average time to complete tasks.

    Args:
        tasks: list of Task

    Returns:
        sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
    """
    # Filter to completed tasks with timestamps -> completed
    # Calculate duration for each -> durations
    # Average the durations -> avg_time
    return sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)


def calculate_estimation_accuracy(tasks: list[Task]) -> Any:
    """
    Calculate how accurate estimates were vs actual.

    Args:
        tasks: list of Task

    Returns:
        sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100
    """
    # Filter to tasks with estimates and actuals -> with_data
    # Calculate estimate vs actual ratio for each -> ratios
    # Average the ratios -> accuracy
    return sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100


def generate_user_performance_report(user: User, tasks: list[Task], period_start: float, period_end: float) -> Any:
    """
    Generate performance metrics for a user.

    Args:
        user: User
        tasks: list of Task
        period_start: number
        period_end: number

    Returns:
        {"user_id": user.id, "completed_tasks": len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed" and t.completed_at is not None and period_start <= t.completed_at <= period_end]), "avg_completion_hours": calculate_average_completion_time([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end]), "estimation_accuracy": calculate_estimation_accuracy([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end])}
    """
    # Get user tasks in period -> user_tasks
    # Calculate completed count -> completed
    # Calculate average completion time -> avg_time
    # Calculate estimation accuracy -> accuracy
    return {"user_id": user.id, "completed_tasks": len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed" and t.completed_at is not None and period_start <= t.completed_at <= period_end]), "avg_completion_hours": calculate_average_completion_time([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end]), "estimation_accuracy": calculate_estimation_accuracy([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end])}


def generate_workflow_summary(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
    """
    Generate executive summary of workflow status.

    Args:
        workflow: Workflow
        current_time: number
        velocity_hours_per_day: number

    Returns:
        {"workflow_id": workflow.id, "name": workflow.name, "status": workflow.status.value, "progress_percent": calculate_workflow_progress(workflow) if len(workflow.tasks) > 0 else 0, "is_on_track": is_workflow_on_track(workflow, current_time, velocity_hours_per_day) if velocity_hours_per_day > 0 else True}
    """
    # Calculate metrics -> metrics
    # Generate summary text -> summary
    return {"workflow_id": workflow.id, "name": workflow.name, "status": workflow.status.value, "progress_percent": calculate_workflow_progress(workflow) if len(workflow.tasks) > 0 else 0, "is_on_track": is_workflow_on_track(workflow, current_time, velocity_hours_per_day) if velocity_hours_per_day > 0 else True}
