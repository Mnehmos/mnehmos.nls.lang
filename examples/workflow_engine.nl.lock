# DO NOT EDIT - Generated by nlsc
# 2026-01-19T00:56:07.200645+00:00

schema_version: 1
generated_at: 2026-01-19T00:56:07.200645+00:00
compiler_version: 0.2.3
llm_backend: mock

modules:
  workflow_engine:
    source_hash: sha256:69fc93e01aeb
    anlus:
      priority-to-weight:
        source_hash: sha256:953fa0fb3c6a
        output_hash: sha256:86dcd917ac60
        output_lines: 218
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
      compare-priorities:
        source_hash: sha256:4ee2274fef51
        output_hash: sha256:cc3b34998d43
        output_lines: 235
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
      get-highest-priority:
        source_hash: sha256:2a865e7b6379
        output_hash: sha256:8c3522a20c61
        output_lines: 252
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
      calculate-pert-estimate:
        source_hash: sha256:6d2a671ed952
        output_hash: sha256:d84b3443cce8
        output_lines: 270
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
      calculate-estimate-variance:
        source_hash: sha256:95c14d212b53
        output_hash: sha256:32a5edd6b75a
        output_lines: 285
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
      calculate-estimate-std-dev:
        source_hash: sha256:8890ddc8c1f4
        output_hash: sha256:1ad5115f8a9a
        output_lines: 300
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
      sum-estimates:
        source_hash: sha256:fd8d8d1383c4
        output_hash: sha256:a1232fbe87c8
        output_lines: 318
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
      average-estimate:
        source_hash: sha256:635c29021f6a
        output_hash: sha256:aed3391832fd
        output_lines: 335
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
      is-task-actionable:
        source_hash: sha256:c2064d306a6b
        output_hash: sha256:af50c6eebc3f
        output_lines: 349
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
      is-task-terminal:
        source_hash: sha256:93f8de294595
        output_hash: sha256:e84c5f534fa5
        output_lines: 362
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
      is-task-blocked:
        source_hash: sha256:5a4b6f28bbc5
        output_hash: sha256:80d3d4493bb6
        output_lines: 375
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
      count-tasks-by-status:
        source_hash: sha256:deea4e71d852
        output_hash: sha256:19bfc4a8f176
        output_lines: 391
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
      get-status-counts:
        source_hash: sha256:6c6ef0c88002
        output_hash: sha256:d213132ff947
        output_lines: 409
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
      get-task-by-id:
        source_hash: sha256:f70944650b6e
        output_hash: sha256:f052289a0a26
        output_lines: 424
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
      get-blocking-tasks:
        source_hash: sha256:7f0be7b4361e
        output_hash: sha256:6b45249e4b0c
        output_lines: 441
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
      has-unmet-dependencies:
        source_hash: sha256:22543026cc15
        output_hash: sha256:dfcf03ebae48
        output_lines: 457
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
      get-ready-tasks:
        source_hash: sha256:2154d1ae75af
        output_hash: sha256:7fea82620c77
        output_lines: 472
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
      get-dependency-depth:
        source_hash: sha256:b479109f1ab0
        output_hash: sha256:776c5d56841b
        output_lines: 489
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
      detect-circular-dependencies:
        source_hash: sha256:c0ae264b19fd
        output_hash: sha256:0054d4db817b
        output_lines: 505
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
      topological-sort-tasks:
        source_hash: sha256:723f03b5f83a
        output_hash: sha256:c502d504870e
        output_lines: 523
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
      create-assignment:
        source_hash: sha256:9f9effcc6262
        output_hash: sha256:b5a4e12a20b1
        output_lines: 541
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
      assign-task-to-user:
        source_hash: sha256:06dc1c61a0e4
        output_hash: sha256:60b211c8fa03
        output_lines: 563
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
      unassign-task:
        source_hash: sha256:18704f9dd50d
        output_hash: sha256:a7740927dcf4
        output_lines: 579
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
      reassign-task:
        source_hash: sha256:514c1e8f8c81
        output_hash: sha256:261e546450df
        output_lines: 597
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
      get-user-tasks:
        source_hash: sha256:0ea2b253dfa0
        output_hash: sha256:245c0ba4b1de
        output_lines: 612
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
      calculate-task-hours:
        source_hash: sha256:ac495e157cec
        output_hash: sha256:c34581e27929
        output_lines: 627
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
      calculate-total-hours:
        source_hash: sha256:c84eea3a92c2
        output_hash: sha256:44bf9b6b156d
        output_lines: 642
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
      calculate-user-workload:
        source_hash: sha256:d452f5e28063
        output_hash: sha256:acdf303f844a
        output_lines: 660
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
      calculate-team-workload:
        source_hash: sha256:3cf16c4e008c
        output_hash: sha256:d6c3328d4a18
        output_lines: 676
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
      find-least-loaded-user:
        source_hash: sha256:368dabb35682
        output_hash: sha256:afad7a3cfe32
        output_lines: 695
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
      find-most-loaded-user:
        source_hash: sha256:54e8303efda0
        output_hash: sha256:1b22c9ee06db
        output_lines: 714
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
      get-overloaded-users:
        source_hash: sha256:dad8903ecb0b
        output_hash: sha256:5a295641039a
        output_lines: 731
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
      balance-workload:
        source_hash: sha256:a6a28ac7d5f4
        output_hash: sha256:e04d541d4891
        output_lines: 749
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
      calculate-workflow-progress:
        source_hash: sha256:508791da2bcd
        output_hash: sha256:8e45f480e63c
        output_lines: 767
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
      calculate-remaining-work:
        source_hash: sha256:854d70d014ef
        output_hash: sha256:650748fa65d2
        output_lines: 782
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
      calculate-completed-work:
        source_hash: sha256:cb4615a3d559
        output_hash: sha256:44500a4d3d8b
        output_lines: 797
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
      calculate-velocity:
        source_hash: sha256:07a6a6a30d27
        output_hash: sha256:45b3788d7cb1
        output_lines: 817
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
      estimate-completion-date:
        source_hash: sha256:ea79fdcc7012
        output_hash: sha256:ac54a34803c3
        output_lines: 837
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
      is-workflow-on-track:
        source_hash: sha256:bc0c2567c340
        output_hash: sha256:0d8e1b8eb6ec
        output_lines: 854
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
      calculate-critical-path-length:
        source_hash: sha256:78f7ebf87620
        output_hash: sha256:352846476a35
        output_lines: 870
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
      calculate-workflow-metrics:
        source_hash: sha256:c9aabf217081
        output_hash: sha256:12b5f43a6497
        output_lines: 890
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
      create-workflow:
        source_hash: sha256:ff0d261f111c
        output_hash: sha256:71b88755cdc8
        output_lines: 907
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
      add-task-to-workflow:
        source_hash: sha256:305471502934
        output_hash: sha256:798909dff749
        output_lines: 924
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
      remove-task-from-workflow:
        source_hash: sha256:d4f16767053f
        output_hash: sha256:eb5dc5a0eaac
        output_lines: 941
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
      activate-workflow:
        source_hash: sha256:ead241d58a16
        output_hash: sha256:ca98f7d29cb8
        output_lines: 963
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
      pause-workflow:
        source_hash: sha256:d46b7557019e
        output_hash: sha256:4af31175e3e7
        output_lines: 979
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
      resume-workflow:
        source_hash: sha256:3173d47ebf03
        output_hash: sha256:a4b099ef2502
        output_lines: 995
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
      all-tasks-terminal:
        source_hash: sha256:ebb129fbfc17
        output_hash: sha256:35ca5a1e206c
        output_lines: 1009
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
      complete-workflow:
        source_hash: sha256:435c54dd1883
        output_hash: sha256:e22b24c61e9d
        output_lines: 1029
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
      archive-workflow:
        source_hash: sha256:34ac75f95270
        output_hash: sha256:16fa9a60a691
        output_lines: 1045
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
      filter-tasks-by-status:
        source_hash: sha256:c6e9478d9cf3
        output_hash: sha256:c3ce2f45416e
        output_lines: 1059
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
      filter-tasks-by-priority:
        source_hash: sha256:9561975c80fa
        output_hash: sha256:4b5d840073da
        output_lines: 1073
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
      filter-tasks-by-assignee:
        source_hash: sha256:122be8c88d6d
        output_hash: sha256:3ef5f456789e
        output_lines: 1087
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
      filter-unassigned-tasks:
        source_hash: sha256:29f1547455f4
        output_hash: sha256:cac8475ac42a
        output_lines: 1101
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
      filter-overdue-tasks:
        source_hash: sha256:171efb67339d
        output_hash: sha256:142e4347ddd1
        output_lines: 1117
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
      filter-tasks-due-soon:
        source_hash: sha256:d1047dbef964
        output_hash: sha256:cb32999fbc48
        output_lines: 1134
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
      search-tasks-by-tag:
        source_hash: sha256:2a8687205516
        output_hash: sha256:0a7713f32f2c
        output_lines: 1148
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
      search-tasks-by-title:
        source_hash: sha256:5556f9676b74
        output_hash: sha256:010daedb4ada
        output_lines: 1163
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
      sort-tasks-by-priority:
        source_hash: sha256:d7d31836432f
        output_hash: sha256:3998b777402c
        output_lines: 1177
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
      sort-tasks-by-due-date:
        source_hash: sha256:ac731e6d0fc3
        output_hash: sha256:5b53c46e1c2e
        output_lines: 1193
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
      sort-tasks-by-created-date:
        source_hash: sha256:11491b6a4fd1
        output_hash: sha256:ad215ac91bcd
        output_lines: 1207
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: t.created_at)
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted(tasks, key=lambda t: t.created_at)
      generate-status-summary:
        source_hash: sha256:b95061df0ed5
        output_hash: sha256:91d462d4deb7
        output_lines: 1221
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: t.created_at)
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted(tasks, key=lambda t: t.created_at)
          
          
          def generate_status_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  get_status_counts(tasks)
              """
              # Get status counts -> counts
              return get_status_counts(tasks)
      generate-priority-summary:
        source_hash: sha256:525fd81b3aa4
        output_hash: sha256:083c327234f6
        output_lines: 1238
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: t.created_at)
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted(tasks, key=lambda t: t.created_at)
          
          
          def generate_status_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  get_status_counts(tasks)
              """
              # Get status counts -> counts
              return get_status_counts(tasks)
          
          
          def generate_priority_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
      calculate-average-completion-time:
        source_hash: sha256:5534269c66f5
        output_hash: sha256:a3d83a0e8ceb
        output_lines: 1254
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: t.created_at)
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted(tasks, key=lambda t: t.created_at)
          
          
          def generate_status_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  get_status_counts(tasks)
              """
              # Get status counts -> counts
              return get_status_counts(tasks)
          
          
          def generate_priority_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> Any:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
      calculate-estimation-accuracy:
        source_hash: sha256:782a43c03b76
        output_hash: sha256:3d08e0ad53ee
        output_lines: 1270
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: t.created_at)
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted(tasks, key=lambda t: t.created_at)
          
          
          def generate_status_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  get_status_counts(tasks)
              """
              # Get status counts -> counts
              return get_status_counts(tasks)
          
          
          def generate_priority_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> Any:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
          
          
          def calculate_estimation_accuracy(tasks: list[Task]) -> Any:
              """
              Calculate how accurate estimates were vs actual.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100
              """
              # Filter to tasks with estimates and actuals -> with_data
              # Calculate estimate vs actual ratio for each -> ratios
              # Average the ratios -> accuracy
              return sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100
      generate-user-performance-report:
        source_hash: sha256:adfece614153
        output_hash: sha256:bbf947286740
        output_lines: 1290
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: t.created_at)
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted(tasks, key=lambda t: t.created_at)
          
          
          def generate_status_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  get_status_counts(tasks)
              """
              # Get status counts -> counts
              return get_status_counts(tasks)
          
          
          def generate_priority_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> Any:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
          
          
          def calculate_estimation_accuracy(tasks: list[Task]) -> Any:
              """
              Calculate how accurate estimates were vs actual.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100
              """
              # Filter to tasks with estimates and actuals -> with_data
              # Calculate estimate vs actual ratio for each -> ratios
              # Average the ratios -> accuracy
              return sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100
          
          
          def generate_user_performance_report(user: User, tasks: list[Task], period_start: float, period_end: float) -> Any:
              """
              Generate performance metrics for a user.
          
              Args:
                  user: User
                  tasks: list of Task
                  period_start: number
                  period_end: number
          
              Returns:
                  {"user_id": user.id, "completed_tasks": len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed" and t.completed_at is not None and period_start <= t.completed_at <= period_end]), "avg_completion_hours": calculate_average_completion_time([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end]), "estimation_accuracy": calculate_estimation_accuracy([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end])}
              """
              # Get user tasks in period -> user_tasks
              # Calculate completed count -> completed
              # Calculate average completion time -> avg_time
              # Calculate estimation accuracy -> accuracy
              return {"user_id": user.id, "completed_tasks": len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed" and t.completed_at is not None and period_start <= t.completed_at <= period_end]), "avg_completion_hours": calculate_average_completion_time([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end]), "estimation_accuracy": calculate_estimation_accuracy([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end])}
      generate-workflow-summary:
        source_hash: sha256:fbfe37221e8d
        output_hash: sha256:83b82e4011c4
        output_lines: 1307
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              created_at: float
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
              assignee_id: Optional[str] = None
              due_date: Optional[float] = None
              completed_at: Optional[float] = None
              estimate: Optional[TimeEstimate] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: Optional[float] = None
              completed_at: Optional[float] = None
              deadline: Optional[float] = None
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: Optional[str] = None
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              is_on_track: bool
              critical_path_length: float
              estimated_completion_date: Optional[float] = None
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> Any:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(priority.value, 0)
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return (1 if priority_to_weight(a) > priority_to_weight(b) else (-1 if priority_to_weight(a) < priority_to_weight(b) else 0))
          
          
          def get_highest_priority(tasks: list[Task]) -> Any:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return max(tasks, key=lambda t: priority_to_weight(t.priority)).priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  calculate_estimate_variance(estimate) ** 0.5
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return calculate_estimate_variance(estimate) ** 0.5
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> Any:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates), realistic=sum(e.realistic for e in estimates), pessimistic=sum(e.pessimistic for e in estimates))
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> Any:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return TimeEstimate(optimistic=sum(e.optimistic for e in estimates) / len(estimates), realistic=sum(e.realistic for e in estimates) / len(estimates), pessimistic=sum(e.pessimistic for e in estimates) / len(estimates))
          
          
          def is_task_actionable(task: Task) -> Any:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> Any:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> Any:
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> Any:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  len([t for t in tasks if t.status.value == status_value])
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return len([t for t in tasks if t.status.value == status_value])
          
          
          def get_status_counts(tasks: list[Task]) -> Any:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts(pending=count_tasks_by_status(tasks, "pending"), in_progress=count_tasks_by_status(tasks, "in_progress"), blocked=count_tasks_by_status(tasks, "blocked"), completed=count_tasks_by_status(tasks, "completed"), cancelled=count_tasks_by_status(tasks, "cancelled"))
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> Any:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  next((t for t in tasks if t.id == task_id), None)
              """
              # Search for task with matching ID -> found
              return next((t for t in tasks if t.id == task_id), None)
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> Any:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return [t for t in all_tasks if t.id in task.dependencies and not is_task_terminal(t)]
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(get_blocking_tasks(task, all_tasks)) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(get_blocking_tasks(task, all_tasks)) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> Any:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return [t for t in tasks if is_task_actionable(t) and not has_unmet_dependencies(t, tasks)]
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> Any:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return 1 + max([get_dependency_depth(get_task_by_id(all_tasks, dep_id), all_tasks) for dep_id in task.dependencies if get_task_by_id(all_tasks, dep_id)], default=0)
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> Any:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  any(t.id in [d for d in t.dependencies] for t in tasks)
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return any(t.id in [d for d in t.dependencies] for t in tasks)
          
          
          def topological_sort_tasks(tasks: list[Task]) -> Any:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return sorted(tasks, key=lambda t: get_dependency_depth(t, tasks))
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: Optional[str] = None) -> Any:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
              """
              # Build assignment record -> assignment
              return Assignment(task_id=task_id, user_id=user_id, assigned_at=timestamp, assigned_by=assigner_id, notes=notes or "")
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return (Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=user.id, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags), create_assignment(task.id, user.id, assigner_id, timestamp))
          
          
          def unassign_task(task: Task) -> Any:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return Task(id=task.id, title=task.title, description=task.description, status=task.status, priority=task.priority, assignee_id=None, created_at=task.created_at, due_date=task.due_date, completed_at=task.completed_at, estimate=task.estimate, actual_hours=task.actual_hours, dependencies=task.dependencies, tags=task.tags)
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> Any:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return assign_task_to_user(unassign_task(task), new_user, assigner_id, timestamp)
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> Any:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              # Filter tasks to user -> user_tasks
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def calculate_task_hours(task: Task) -> Any:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  calculate_pert_estimate(task.estimate) if task.estimate else 8.0
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return calculate_pert_estimate(task.estimate) if task.estimate else 8.0
          
          
          def calculate_total_hours(tasks: list[Task]) -> Any:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_task_hours(t) for t in tasks)
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return sum(calculate_task_hours(t) for t in tasks)
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> Any:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport(user_id=user.id, total_tasks=len(get_user_tasks(tasks, user.id)), pending_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "pending"]), in_progress_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "in_progress"]), completed_tasks=len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]), utilization_percent=min(100, calculate_total_hours([t for t in get_user_tasks(tasks, user.id) if not is_task_terminal(t)]) / max(user.capacity, 1) * 100))
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> Any:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return WorkloadReport(user_id="team", total_tasks=len(tasks), pending_tasks=len([t for t in tasks if t.status.value == "pending"]), in_progress_tasks=len([t for t in tasks if t.status.value == "in_progress"]), completed_tasks=len([t for t in tasks if t.status.value == "completed"]), total_estimated_hours=calculate_total_hours([t for t in tasks if not is_task_terminal(t)]), utilization_percent=min(100, sum(calculate_user_workload(u, tasks).utilization_percent for u in users) / max(len(users), 1)))
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return min(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> Any:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return max(users, key=lambda u: calculate_user_workload(u, tasks).utilization_percent)
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return [u for u in users if calculate_user_workload(u, tasks).utilization_percent > threshold]
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> Any:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return [ReassignmentSuggestion(task_id=t.id, from_user_id=t.assignee_id or "", to_user_id=find_least_loaded_user(users, tasks).id, reason="Workload balancing") for u in get_overloaded_users(users, tasks, threshold) for t in get_user_tasks(tasks, u.id)[:1]]
          
          
          def calculate_workflow_progress(workflow: Workflow) -> Any:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return len([t for t in workflow.tasks if t.status.value == "completed"]) / len(workflow.tasks) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> Any:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return calculate_total_hours([t for t in tasks if not is_task_terminal(t)])
          
          
          def calculate_completed_work(tasks: list[Task]) -> Any:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(t.actual_hours for t in tasks if t.status.value == "completed")
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return sum(t.actual_hours for t in tasks if t.status.value == "completed")
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> Any:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return calculate_completed_work(tasks) / max((end_time - start_time) / 86400, 1)
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return current_time + (calculate_remaining_work(workflow.tasks) / velocity_hours_per_day) * 86400
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return workflow.deadline is None or estimate_completion_date(workflow, current_time, velocity_hours_per_day) <= workflow.deadline
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> Any:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return max([calculate_task_hours(t) * get_dependency_depth(t, tasks) for t in tasks], default=0)
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics(workflow_id=workflow.id, total_tasks=len(workflow.tasks), completed_tasks=len([t for t in workflow.tasks if t.status.value == "completed"]), blocked_tasks=len([t for t in workflow.tasks if t.status.value == "blocked"]), completion_percent=calculate_workflow_progress(workflow), estimated_completion_date=estimate_completion_date(workflow, current_time, velocity_hours_per_day), is_on_track=is_workflow_on_track(workflow, current_time, velocity_hours_per_day), critical_path_length=calculate_critical_path_length(workflow.tasks))
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> Any:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
              """
              # Create workflow with draft status -> workflow
              return Workflow(id=id, name=name, description="", status=WorkflowStatus(value="draft"), owner_id=owner_id, tasks=[], created_at=timestamp, started_at=None, completed_at=None, deadline=None)
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> Any:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=workflow.tasks + [task], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> Any:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=workflow.status, owner_id=workflow.owner_id, tasks=[t for t in workflow.tasks if t.id != task_id], created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=timestamp, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def pause_workflow(workflow: Workflow) -> Any:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="paused"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def resume_workflow(workflow: Workflow) -> Any:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="active"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def all_tasks_terminal(tasks: list[Task]) -> Any:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all(is_task_terminal(t) for t in tasks)
              """
              # Check each task is terminal -> all_done
              return all(is_task_terminal(t) for t in tasks)
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> Any:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="completed"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=timestamp, deadline=workflow.deadline)
          
          
          def archive_workflow(workflow: Workflow) -> Any:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return Workflow(id=workflow.id, name=workflow.name, description=workflow.description, status=WorkflowStatus(value="archived"), owner_id=workflow.owner_id, tasks=workflow.tasks, created_at=workflow.created_at, started_at=workflow.started_at, completed_at=workflow.completed_at, deadline=workflow.deadline)
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> Any:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  [t for t in tasks if t.status.value == status.value]
              """
              return [t for t in tasks if t.status.value == status.value]
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> Any:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  [t for t in tasks if t.priority.value == priority.value]
              """
              return [t for t in tasks if t.priority.value == priority.value]
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> Any:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  [t for t in tasks if t.assignee_id == user_id]
              """
              return [t for t in tasks if t.assignee_id == user_id]
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> Any:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  [t for t in tasks if t.assignee_id is None]
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return [t for t in tasks if t.assignee_id is None]
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> Any:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return [t for t in tasks if t.due_date is not None and t.due_date < current_time and not is_task_terminal(t)]
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> Any:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return [t for t in tasks if t.due_date is not None and current_time <= t.due_date <= current_time + window_hours * 3600 and not is_task_terminal(t)]
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> Any:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  [t for t in tasks if tag in t.tags]
              """
              return [t for t in tasks if tag in t.tags]
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> Any:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  [t for t in tasks if search_term.lower() in t.title.lower()]
              """
              # Filter tasks where title contains term -> matching
              return [t for t in tasks if search_term.lower() in t.title.lower()]
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> Any:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted(tasks, key=lambda t: priority_to_weight(t.priority), reverse=True)
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted([t for t in tasks if t.due_date is not None], key=lambda t: cast(float, t.due_date)) + [t for t in tasks if t.due_date is None]
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> Any:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted(tasks, key=lambda t: t.created_at)
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted(tasks, key=lambda t: t.created_at)
          
          
          def generate_status_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  get_status_counts(tasks)
              """
              # Get status counts -> counts
              return get_status_counts(tasks)
          
          
          def generate_priority_summary(tasks: list[Task]) -> Any:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts(critical=len([t for t in tasks if t.priority.value == "critical"]), high=len([t for t in tasks if t.priority.value == "high"]), medium=len([t for t in tasks if t.priority.value == "medium"]), low=len([t for t in tasks if t.priority.value == "low"]))
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> Any:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return sum((t.completed_at - t.created_at) / 3600 for t in tasks if t.status.value == "completed" and t.completed_at is not None) / max(len([t for t in tasks if t.status.value == "completed" and t.completed_at is not None]), 1)
          
          
          def calculate_estimation_accuracy(tasks: list[Task]) -> Any:
              """
              Calculate how accurate estimates were vs actual.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100
              """
              # Filter to tasks with estimates and actuals -> with_data
              # Calculate estimate vs actual ratio for each -> ratios
              # Average the ratios -> accuracy
              return sum(calculate_pert_estimate(t.estimate) / max(t.actual_hours, 0.1) for t in tasks if t.estimate is not None and t.actual_hours > 0) / max(len([t for t in tasks if t.estimate is not None and t.actual_hours > 0]), 1) * 100
          
          
          def generate_user_performance_report(user: User, tasks: list[Task], period_start: float, period_end: float) -> Any:
              """
              Generate performance metrics for a user.
          
              Args:
                  user: User
                  tasks: list of Task
                  period_start: number
                  period_end: number
          
              Returns:
                  {"user_id": user.id, "completed_tasks": len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed" and t.completed_at is not None and period_start <= t.completed_at <= period_end]), "avg_completion_hours": calculate_average_completion_time([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end]), "estimation_accuracy": calculate_estimation_accuracy([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end])}
              """
              # Get user tasks in period -> user_tasks
              # Calculate completed count -> completed
              # Calculate average completion time -> avg_time
              # Calculate estimation accuracy -> accuracy
              return {"user_id": user.id, "completed_tasks": len([t for t in get_user_tasks(tasks, user.id) if t.status.value == "completed" and t.completed_at is not None and period_start <= t.completed_at <= period_end]), "avg_completion_hours": calculate_average_completion_time([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end]), "estimation_accuracy": calculate_estimation_accuracy([t for t in get_user_tasks(tasks, user.id) if t.completed_at is not None and period_start <= t.completed_at <= period_end])}
          
          
          def generate_workflow_summary(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> Any:
              """
              Generate executive summary of workflow status.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  {"workflow_id": workflow.id, "name": workflow.name, "status": workflow.status.value, "progress_percent": calculate_workflow_progress(workflow) if len(workflow.tasks) > 0 else 0, "is_on_track": is_workflow_on_track(workflow, current_time, velocity_hours_per_day) if velocity_hours_per_day > 0 else True}
              """
              # Calculate metrics -> metrics
              # Generate summary text -> summary
              return {"workflow_id": workflow.id, "name": workflow.name, "status": workflow.status.value, "progress_percent": calculate_workflow_progress(workflow) if len(workflow.tasks) > 0 else 0, "is_on_track": is_workflow_on_track(workflow, current_time, velocity_hours_per_day) if velocity_hours_per_day > 0 else True}

targets:
  python:
    file: examples\workflow_engine.py
    hash: sha256:151ff507f24c
    lines: 1317