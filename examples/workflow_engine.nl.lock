# DO NOT EDIT - Generated by nlsc
# 2026-01-19T00:28:34.745943+00:00

schema_version: 1
generated_at: 2026-01-19T00:28:34.745943+00:00
compiler_version: 0.2.3
llm_backend: mock

modules:
  workflow_engine:
    source_hash: sha256:d80323f7027e
    anlus:
      priority-to-weight:
        source_hash: sha256:1561c8e3d750
        output_hash: sha256:d1f48293cc7a
        output_lines: 218
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
      compare-priorities:
        source_hash: sha256:7151c5292c38
        output_hash: sha256:329c5b584557
        output_lines: 235
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
      get-highest-priority:
        source_hash: sha256:e752d9dc0073
        output_hash: sha256:95858af0ca95
        output_lines: 252
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
      calculate-pert-estimate:
        source_hash: sha256:6d2a671ed952
        output_hash: sha256:1cddcd06cb05
        output_lines: 270
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
      calculate-estimate-variance:
        source_hash: sha256:95c14d212b53
        output_hash: sha256:fc4ebe20b7c7
        output_lines: 285
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
      calculate-estimate-std-dev:
        source_hash: sha256:30193461917d
        output_hash: sha256:a3d9c521a677
        output_lines: 300
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
      sum-estimates:
        source_hash: sha256:544361b3c0ec
        output_hash: sha256:b920d1fbcd20
        output_lines: 318
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
      average-estimate:
        source_hash: sha256:b188020feefb
        output_hash: sha256:aed19bd0a910
        output_lines: 335
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
      is-task-actionable:
        source_hash: sha256:c2064d306a6b
        output_hash: sha256:c5825155aba6
        output_lines: 349
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
      is-task-terminal:
        source_hash: sha256:93f8de294595
        output_hash: sha256:6fcf6100bc00
        output_lines: 362
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
      is-task-blocked:
        source_hash: sha256:5a4b6f28bbc5
        output_hash: sha256:57788d8100fa
        output_lines: 375
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
      count-tasks-by-status:
        source_hash: sha256:6449c0580720
        output_hash: sha256:0bfa37938118
        output_lines: 391
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
      get-status-counts:
        source_hash: sha256:6090d58ada99
        output_hash: sha256:5c3b6dc0eca5
        output_lines: 409
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
      get-task-by-id:
        source_hash: sha256:a7789118b185
        output_hash: sha256:7afc3e09d5e2
        output_lines: 424
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
      get-blocking-tasks:
        source_hash: sha256:7fdd37f3d86b
        output_hash: sha256:41ba1da5bbfc
        output_lines: 441
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
      has-unmet-dependencies:
        source_hash: sha256:1f8b6828cb2c
        output_hash: sha256:3c6f54be269d
        output_lines: 457
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
      get-ready-tasks:
        source_hash: sha256:07734dc2637d
        output_hash: sha256:f35a944fe9a5
        output_lines: 472
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
      get-dependency-depth:
        source_hash: sha256:0155200eb298
        output_hash: sha256:b5c9cf56e6fc
        output_lines: 489
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
      detect-circular-dependencies:
        source_hash: sha256:1d1dd2508a0f
        output_hash: sha256:d4d253985f1d
        output_lines: 505
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
      topological-sort-tasks:
        source_hash: sha256:11d28e36e854
        output_hash: sha256:a87e961b125d
        output_lines: 523
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
      create-assignment:
        source_hash: sha256:ea7d9b32234c
        output_hash: sha256:908140e04d4a
        output_lines: 541
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
      assign-task-to-user:
        source_hash: sha256:0bf9aa49b6ca
        output_hash: sha256:a49372612c5e
        output_lines: 563
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
      unassign-task:
        source_hash: sha256:452cb0d05267
        output_hash: sha256:2848441c6e95
        output_lines: 579
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
      reassign-task:
        source_hash: sha256:f71bb8a290fa
        output_hash: sha256:833fd58fc368
        output_lines: 597
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
      get-user-tasks:
        source_hash: sha256:4d8fbdbd928c
        output_hash: sha256:65601fce0b35
        output_lines: 612
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
      calculate-task-hours:
        source_hash: sha256:54807b9a020d
        output_hash: sha256:472280de0884
        output_lines: 627
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
      calculate-total-hours:
        source_hash: sha256:c29dc81d2d10
        output_hash: sha256:5d8cc5a45dce
        output_lines: 642
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
      calculate-user-workload:
        source_hash: sha256:076a1f5d5c64
        output_hash: sha256:c098e5e89530
        output_lines: 660
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
      calculate-team-workload:
        source_hash: sha256:6b180eb268fa
        output_hash: sha256:ccc9db74e991
        output_lines: 676
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
      find-least-loaded-user:
        source_hash: sha256:fd11bd571926
        output_hash: sha256:8b4a08f1e1bd
        output_lines: 695
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
      find-most-loaded-user:
        source_hash: sha256:e604ba631b14
        output_hash: sha256:6a41174a13af
        output_lines: 714
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
      get-overloaded-users:
        source_hash: sha256:48e10e1ecc99
        output_hash: sha256:6646783b8d99
        output_lines: 731
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
      balance-workload:
        source_hash: sha256:af43e3a4084d
        output_hash: sha256:cd7a56fe12a9
        output_lines: 749
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
      calculate-workflow-progress:
        source_hash: sha256:1fea3543417c
        output_hash: sha256:0606c34f226e
        output_lines: 767
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
      calculate-remaining-work:
        source_hash: sha256:696a88bcd36f
        output_hash: sha256:0deacb6fa623
        output_lines: 782
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
      calculate-completed-work:
        source_hash: sha256:75afe3b65dfa
        output_hash: sha256:286d3c1165cb
        output_lines: 797
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
      calculate-velocity:
        source_hash: sha256:def4cee19d87
        output_hash: sha256:866ba78e9ae3
        output_lines: 817
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
      estimate-completion-date:
        source_hash: sha256:f8376e6e312e
        output_hash: sha256:b8eadba5b2f3
        output_lines: 837
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
      is-workflow-on-track:
        source_hash: sha256:8ce39bedc538
        output_hash: sha256:45cd293be4b8
        output_lines: 854
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
      calculate-critical-path-length:
        source_hash: sha256:b37d0d61caf2
        output_hash: sha256:42efab847f89
        output_lines: 870
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
      calculate-workflow-metrics:
        source_hash: sha256:31ca50ff9e29
        output_hash: sha256:b8a872388928
        output_lines: 890
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
      create-workflow:
        source_hash: sha256:1ca62468d6f1
        output_hash: sha256:4b3c9f4a51e3
        output_lines: 907
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
      add-task-to-workflow:
        source_hash: sha256:16f55011448c
        output_hash: sha256:b5d1038e2d07
        output_lines: 924
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
      remove-task-from-workflow:
        source_hash: sha256:896abd53daec
        output_hash: sha256:90c10a34068b
        output_lines: 941
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
      activate-workflow:
        source_hash: sha256:98635e1ef4d7
        output_hash: sha256:1005fb104963
        output_lines: 963
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
      pause-workflow:
        source_hash: sha256:cd92eb3b03ea
        output_hash: sha256:d0f43f5c1425
        output_lines: 979
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
      resume-workflow:
        source_hash: sha256:190cba4fc4c7
        output_hash: sha256:6825ce1f5ab2
        output_lines: 995
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
      all-tasks-terminal:
        source_hash: sha256:c22e701b4fcd
        output_hash: sha256:c131d9b55887
        output_lines: 1009
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
      complete-workflow:
        source_hash: sha256:a2c5241878ba
        output_hash: sha256:7f07ca49c7de
        output_lines: 1029
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
      archive-workflow:
        source_hash: sha256:10a4caec031f
        output_hash: sha256:94ec6bdb0734
        output_lines: 1045
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
      filter-tasks-by-status:
        source_hash: sha256:fc0e0f145a3a
        output_hash: sha256:23557cc50a28
        output_lines: 1059
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
      filter-tasks-by-priority:
        source_hash: sha256:b019ea6e795c
        output_hash: sha256:3ef8c7ff1714
        output_lines: 1073
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
      filter-tasks-by-assignee:
        source_hash: sha256:71b4267787c6
        output_hash: sha256:60ee18b09902
        output_lines: 1087
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
      filter-unassigned-tasks:
        source_hash: sha256:d1590a035c62
        output_hash: sha256:111d2c57d205
        output_lines: 1101
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
      filter-overdue-tasks:
        source_hash: sha256:f5a58d8c5589
        output_hash: sha256:4495ac706cac
        output_lines: 1117
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
      filter-tasks-due-soon:
        source_hash: sha256:8aa7d21db77d
        output_hash: sha256:c3dd77f2a500
        output_lines: 1134
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
      search-tasks-by-tag:
        source_hash: sha256:99c152cfcadd
        output_hash: sha256:fa428dbee362
        output_lines: 1149
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
      search-tasks-by-title:
        source_hash: sha256:ed066dcb12fa
        output_hash: sha256:55c0f07f13cd
        output_lines: 1164
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
      sort-tasks-by-priority:
        source_hash: sha256:e29d6b7c405a
        output_hash: sha256:a62b04f43d31
        output_lines: 1178
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
      sort-tasks-by-due-date:
        source_hash: sha256:5a402c671e3b
        output_hash: sha256:10d2c3ab070c
        output_lines: 1194
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
      sort-tasks-by-created-date:
        source_hash: sha256:26d3f678772a
        output_hash: sha256:15addef58618
        output_lines: 1208
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted list of tasks
      generate-status-summary:
        source_hash: sha256:f08f139383b7
        output_hash: sha256:03483966c6c7
        output_lines: 1222
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted list of tasks
          
          
          def generate_status_summary(tasks: list[Task]) -> StatusCounts:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts
              """
              # Get status counts -> counts
              return StatusCounts
      generate-priority-summary:
        source_hash: sha256:169593ed0d7b
        output_hash: sha256:c0461f40089c
        output_lines: 1239
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted list of tasks
          
          
          def generate_status_summary(tasks: list[Task]) -> StatusCounts:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts
              """
              # Get status counts -> counts
              return StatusCounts
          
          
          def generate_priority_summary(tasks: list[Task]) -> PriorityCounts:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts
      calculate-average-completion-time:
        source_hash: sha256:46c3b93e1aba
        output_hash: sha256:0a3fd9eb98c9
        output_lines: 1255
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted list of tasks
          
          
          def generate_status_summary(tasks: list[Task]) -> StatusCounts:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts
              """
              # Get status counts -> counts
              return StatusCounts
          
          
          def generate_priority_summary(tasks: list[Task]) -> PriorityCounts:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> average completion time in hours:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  average completion time in hours
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return average completion time in hours
      calculate-estimation-accuracy:
        source_hash: sha256:e130fc32761a
        output_hash: sha256:51b0995ad452
        output_lines: 1271
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted list of tasks
          
          
          def generate_status_summary(tasks: list[Task]) -> StatusCounts:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts
              """
              # Get status counts -> counts
              return StatusCounts
          
          
          def generate_priority_summary(tasks: list[Task]) -> PriorityCounts:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> average completion time in hours:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  average completion time in hours
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return average completion time in hours
          
          
          def calculate_estimation_accuracy(tasks: list[Task]) -> accuracy percentage:
              """
              Calculate how accurate estimates were vs actual.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  accuracy percentage
              """
              # Filter to tasks with estimates and actuals -> with_data
              # Calculate estimate vs actual ratio for each -> ratios
              # Average the ratios -> accuracy
              return accuracy percentage
      generate-user-performance-report:
        source_hash: sha256:1c0c78125320
        output_hash: sha256:b4b388cb8574
        output_lines: 1291
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted list of tasks
          
          
          def generate_status_summary(tasks: list[Task]) -> StatusCounts:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts
              """
              # Get status counts -> counts
              return StatusCounts
          
          
          def generate_priority_summary(tasks: list[Task]) -> PriorityCounts:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> average completion time in hours:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  average completion time in hours
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return average completion time in hours
          
          
          def calculate_estimation_accuracy(tasks: list[Task]) -> accuracy percentage:
              """
              Calculate how accurate estimates were vs actual.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  accuracy percentage
              """
              # Filter to tasks with estimates and actuals -> with_data
              # Calculate estimate vs actual ratio for each -> ratios
              # Average the ratios -> accuracy
              return accuracy percentage
          
          
          def generate_user_performance_report(user: User, tasks: list[Task], period_start: float, period_end: float) -> performance report for user:
              """
              Generate performance metrics for a user.
          
              Args:
                  user: User
                  tasks: list of Task
                  period_start: number
                  period_end: number
          
              Returns:
                  performance report for user
              """
              # Get user tasks in period -> user_tasks
              # Calculate completed count -> completed
              # Calculate average completion time -> avg_time
              # Calculate estimation accuracy -> accuracy
              return performance report for user
      generate-workflow-summary:
        source_hash: sha256:d30e52e0e090
        output_hash: sha256:ed94462bdc60
        output_lines: 1308
        generated_code: |
          @dataclass
          class Priority:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class TaskStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class WorkflowStatus:
              value: str
          
              def __post_init__(self):
                  if not self.value:
                      raise ValueError('value is required')
          
          
          @dataclass
          class User:
              id: str
              name: str
              email: str
              role: str
              capacity: float
              skills: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.email:
                      raise ValueError('email is required')
                  if not self.role:
                      raise ValueError('role is required')
          
          
          @dataclass
          class TimeEstimate:
              optimistic: float
              realistic: float
              pessimistic: float
          
              def __post_init__(self):
                  if not (self.optimistic <= self.realistic):
                      raise ValueError("Invariant violated: optimistic <= realistic")
                  if not (self.realistic <= self.pessimistic):
                      raise ValueError("Invariant violated: realistic <= pessimistic")
                  if not (self.pessimistic > 0):
                      raise ValueError("Invariant violated: pessimistic > 0")
          
          
          @dataclass
          class Task:
              id: str
              title: str
              description: str
              status: TaskStatus
              priority: Priority
              assignee_id: str
              created_at: float
              due_date: float
              completed_at: float
              estimate: TimeEstimate
              actual_hours: float
              dependencies: list[str]
              tags: list[str]
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.title:
                      raise ValueError('title is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.priority:
                      raise ValueError('priority is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
                  if not (self.actual_hours >= 0):
                      raise ValueError("Invariant violated: actual_hours >= 0")
          
          
          @dataclass
          class Workflow:
              id: str
              name: str
              description: str
              status: WorkflowStatus
              owner_id: str
              tasks: list[Task]
              created_at: float
              started_at: float
              completed_at: float
              deadline: float
          
              def __post_init__(self):
                  if not self.id:
                      raise ValueError('id is required')
                  if not self.name:
                      raise ValueError('name is required')
                  if not self.status:
                      raise ValueError('status is required')
                  if not self.owner_id:
                      raise ValueError('owner_id is required')
                  if not self.created_at:
                      raise ValueError('created_at is required')
          
          
          @dataclass
          class Assignment:
              task_id: str
              user_id: str
              assigned_at: float
              assigned_by: str
              notes: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not self.assigned_at:
                      raise ValueError('assigned_at is required')
                  if not self.assigned_by:
                      raise ValueError('assigned_by is required')
          
          
          @dataclass
          class WorkloadReport:
              user_id: str
              total_tasks: float
              pending_tasks: float
              in_progress_tasks: float
              completed_tasks: float
              total_estimated_hours: float
              utilization_percent: float
          
              def __post_init__(self):
                  if not self.user_id:
                      raise ValueError('user_id is required')
                  if not (self.utilization_percent >= 0):
                      raise ValueError("Invariant violated: utilization_percent >= 0")
                  if not (self.utilization_percent <= 100):
                      raise ValueError("Invariant violated: utilization_percent <= 100")
          
          
          @dataclass
          class WorkflowMetrics:
              workflow_id: str
              total_tasks: float
              completed_tasks: float
              blocked_tasks: float
              completion_percent: float
              estimated_completion_date: float
              is_on_track: bool
              critical_path_length: float
          
              def __post_init__(self):
                  if not self.workflow_id:
                      raise ValueError('workflow_id is required')
          
          
          @dataclass
          class StatusCounts:
              pending: float
              in_progress: float
              blocked: float
              completed: float
              cancelled: float
          
          
          @dataclass
          class PriorityCounts:
              critical: float
              high: float
              medium: float
              low: float
          
          
          @dataclass
          class ReassignmentSuggestion:
              task_id: str
              from_user_id: str
              to_user_id: str
              reason: str
          
              def __post_init__(self):
                  if not self.task_id:
                      raise ValueError('task_id is required')
                  if not self.from_user_id:
                      raise ValueError('from_user_id is required')
                  if not self.to_user_id:
                      raise ValueError('to_user_id is required')
          
          
          def priority_to_weight(priority: Priority) -> weight based on priority value:
              """
              Convert priority to numeric weight for sorting.
          
              Args:
                  priority: Priority
          
              Returns:
                  weight based on priority value
              """
              # Map critical to 4, high to 3, medium to 2, low to 1 -> weight
              return weight based on priority value
          
          
          def compare_priorities(a: Priority, b: Priority) -> Any:
              """
              Compare two priorities, returning -1, 0, or 1.
          
              Args:
                  a: Priority
                  b: Priority
          
              Returns:
                  1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
              """
              # Get weight of a -> weight_a
              # Get weight of b -> weight_b
              # Calculate difference -> diff
              return 1 if weight_a > weight_b, -1 if weight_a < weight_b, else 0
          
          
          def get_highest_priority(tasks: list[Task]) -> highest priority:
              """
              Get the highest priority from a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  highest priority
              """
              if not (len(tasks) > 0):
                  raise ValueError('Cannot get priority from empty list')
              # Extract priorities from all tasks -> priorities
              # Find maximum by weight -> highest
              return highest priority
          
          
          def calculate_pert_estimate(estimate: TimeEstimate) -> Any:
              """
              Calculate PERT estimate using formula (O + 4M + P) / 6.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
              """
              if not (estimate.optimistic <= estimate.realistic):
                  raise ValueError('Optimistic must be <= realistic')
              if not (estimate.realistic <= estimate.pessimistic):
                  raise ValueError('Realistic must be <= pessimistic')
              # Apply PERT formula -> pert
              return (estimate.optimistic + 4 * estimate.realistic + estimate.pessimistic) / 6
          
          
          def calculate_estimate_variance(estimate: TimeEstimate) -> Any:
              """
              Calculate variance in time estimate for risk assessment.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
              """
              # Calculate range -> range_val
              # Divide by 6 and square -> variance
              return ((estimate.pessimistic - estimate.optimistic) / 6) ** 2
          
          
          def calculate_estimate_std_dev(estimate: TimeEstimate) -> Any:
              """
              Calculate standard deviation of time estimate.
          
              Args:
                  estimate: TimeEstimate
          
              Returns:
                  sqrt(variance)
              """
              # Calculate variance -> var
              # Take square root -> std_dev
              return sqrt(variance)
          
          
          def sum_estimates(estimates: list[TimeEstimate]) -> TimeEstimate with summed values:
              """
              Sum multiple time estimates into one combined estimate.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  TimeEstimate with summed values
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot sum empty list of estimates')
              # Sum all optimistic values -> total_opt
              # Sum all realistic values -> total_real
              # Sum all pessimistic values -> total_pess
              return TimeEstimate with summed values
          
          
          def average_estimate(estimates: list[TimeEstimate]) -> average TimeEstimate:
              """
              Calculate average of multiple time estimates.
          
              Args:
                  estimates: list of TimeEstimate
          
              Returns:
                  average TimeEstimate
              """
              if not (len(estimates) > 0):
                  raise ValueError('Cannot average empty list')
              # Sum all estimates -> total
              # Divide each component by count -> avg
              return average TimeEstimate
          
          
          def is_task_actionable(task: Task) -> task.status.value in ["pending", "in_progress"]:
              """
              Check if a task can be worked on (not blocked or completed).
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["pending", "in_progress"]
              """
              # Check status is pending or in_progress -> actionable
              return task.status.value in ["pending", "in_progress"]
          
          
          def is_task_terminal(task: Task) -> task.status.value in ["completed", "cancelled"]:
              """
              Check if a task is in a terminal state.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value in ["completed", "cancelled"]
              """
              return task.status.value in ["completed", "cancelled"]
          
          
          def is_task_blocked(task: Task) -> task.status.value == "blocked":
              """
              Check if a task has blocked status.
          
              Args:
                  task: Task
          
              Returns:
                  task.status.value == "blocked"
              """
              return task.status.value == "blocked"
          
          
          def count_tasks_by_status(tasks: list[Task], status_value: str) -> count of matching tasks:
              """
              Count tasks matching a specific status.
          
              Args:
                  tasks: list of Task
                  status_value: string
          
              Returns:
                  count of matching tasks
              """
              # Filter tasks to matching status -> matching
              # Count matching tasks -> count
              return count of matching tasks
          
          
          def get_status_counts(tasks: list[Task]) -> StatusCounts with all counts:
              """
              Get counts of tasks by each status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts with all counts
              """
              # Count pending tasks -> pending
              # Count in_progress tasks -> in_progress
              # Count blocked tasks -> blocked
              # Count completed tasks -> completed
              # Count cancelled tasks -> cancelled
              return StatusCounts with all counts
          
          
          def get_task_by_id(tasks: list[Task], task_id: str) -> found task or None:
              """
              Find a task by its ID.
          
              Args:
                  tasks: list of Task
                  task_id: string
          
              Returns:
                  found task or None
              """
              # Search for task with matching ID -> found
              return found task or None
          
          
          def get_blocking_tasks(task: Task, all_tasks: list[Task]) -> list of blocking tasks:
              """
              Get list of incomplete tasks that block a given task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  list of blocking tasks
              """
              # Get task IDs from dependencies -> dep_ids
              # Find tasks matching those IDs -> deps
              # Filter to non-terminal tasks -> blocking
              return list of blocking tasks
          
          
          def has_unmet_dependencies(task: Task, all_tasks: list[Task]) -> Any:
              """
              Check if a task is blocked by incomplete dependencies.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  len(blockers) > 0
              """
              # Get blocking tasks -> blockers
              # Check if any blockers exist -> blocked
              return len(blockers) > 0
          
          
          def get_ready_tasks(tasks: list[Task]) -> list of ready tasks:
              """
              Get all tasks that are ready to be worked on.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  list of ready tasks
              """
              # Filter to actionable tasks -> actionable
              # Filter to those not blocked -> ready
              return list of ready tasks
          
          
          def get_dependency_depth(task: Task, all_tasks: list[Task]) -> maximum dependency depth:
              """
              Calculate the maximum dependency chain depth for a task.
          
              Args:
                  task: Task
                  all_tasks: list of Task
          
              Returns:
                  maximum dependency depth
              """
              # Get direct dependencies -> deps
              # Recursively calculate depth of each -> depths
              # Return max depth plus 1 -> total_depth
              return maximum dependency depth
          
          
          def detect_circular_dependencies(tasks: list[Task]) -> True if circular dependency exists, False otherwise:
              """
              Detect if there are circular dependencies in task list.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  True if circular dependency exists, False otherwise
              """
              # Build adjacency list -> adj
              # Track visited and recursion stack -> visited, rec_stack
              # DFS from each unvisited node -> has_cycle
              return True if circular dependency exists, False otherwise
          
          
          def topological_sort_tasks(tasks: list[Task]) -> topologically sorted list of tasks:
              """
              Sort tasks by dependency order.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  topologically sorted list of tasks
              """
              if not (not detect_circular_dependencies(tasks)):
                  raise ValueError('Circular dependency detected')
              # Build dependency graph -> graph
              # Find tasks with no dependencies -> roots
              # Process queue, adding tasks when deps satisfied -> sorted_list
              return topologically sorted list of tasks
          
          
          def create_assignment(task_id: str, user_id: str, assigner_id: str, timestamp: float, notes: str) -> new Assignment:
              """
              Create a new assignment record.
          
              Args:
                  task_id: string
                  user_id: string
                  assigner_id: string
                  timestamp: number
                  notes: string
          
              Returns:
                  new Assignment
              """
              # Build assignment record -> assignment
              return new Assignment
          
          
          def assign_task_to_user(task: Task, user: User, assigner_id: str, timestamp: float) -> tuple of updated_task and assignment:
              """
              Assign a task to a user.
          
              Args:
                  task: Task
                  user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  tuple of updated_task and assignment
              """
              if not (is_task_actionable(task)):
                  raise ValueError('Cannot assign terminal task')
              if not (user.capacity > 0):
                  raise ValueError('User has no available capacity')
              # Create assignment record -> assignment
              # Update task with assignee -> updated_task
              return tuple of updated_task and assignment
          
          
          def unassign_task(task: Task) -> updated task with no assignee:
              """
              Remove assignment from a task.
          
              Args:
                  task: Task
          
              Returns:
                  updated task with no assignee
              """
              if not (task.assignee_id != None):
                  raise ValueError('Task is not assigned')
              # Clear assignee_id from task -> updated
              return updated task with no assignee
          
          
          def reassign_task(task: Task, new_user: User, assigner_id: str, timestamp: float) -> reassigned task and new assignment:
              """
              Reassign a task from one user to another.
          
              Args:
                  task: Task
                  new_user: User
                  assigner_id: string
                  timestamp: number
          
              Returns:
                  reassigned task and new assignment
              """
              # Unassign current user -> unassigned
              # Assign to new user -> reassigned
              return reassigned task and new assignment
          
          
          def get_user_tasks(tasks: list[Task], user_id: str) -> list of tasks assigned to user:
              """
              Get all tasks assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  list of tasks assigned to user
              """
              # Filter tasks to user -> user_tasks
              return list of tasks assigned to user
          
          
          def calculate_task_hours(task: Task) -> estimated hours for task:
              """
              Calculate estimated hours for a single task.
          
              Args:
                  task: Task
          
              Returns:
                  estimated hours for task
              """
              # Check if task has estimate -> has_est
              # Calculate PERT if has estimate, else default -> hours
              return estimated hours for task
          
          
          def calculate_total_hours(tasks: list[Task]) -> total estimated hours:
              """
              Calculate total estimated hours for a list of tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total estimated hours
              """
              # Calculate hours for each task -> hours_list
              # Sum all hours -> total
              return total estimated hours
          
          
          def calculate_user_workload(user: User, tasks: list[Task]) -> WorkloadReport for the user:
              """
              Calculate workload report for a user.
          
              Args:
                  user: User
                  tasks: list of Task
          
              Returns:
                  WorkloadReport for the user
              """
              # Filter tasks assigned to user -> user_tasks
              # Count by status -> counts
              # Sum estimates for incomplete tasks -> estimated_hours
              # Calculate utilization -> util_percent
              return WorkloadReport for the user
          
          
          def calculate_team_workload(users: list[User], tasks: list[Task]) -> aggregated workload report:
              """
              Calculate combined workload for a team.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  aggregated workload report
              """
              # Calculate workload for each user -> workloads
              # Aggregate totals -> team_totals
              return aggregated workload report
          
          
          def find_least_loaded_user(users: list[User], tasks: list[Task]) -> user with lowest workload:
              """
              Find user with lowest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with lowest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find minimum utilization -> min_load
              # Return user with minimum -> least_loaded
              return user with lowest workload
          
          
          def find_most_loaded_user(users: list[User], tasks: list[Task]) -> user with highest workload:
              """
              Find user with highest current workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
          
              Returns:
                  user with highest workload
              """
              if not (len(users) > 0):
                  raise ValueError('No users provided')
              # Calculate workload for each user -> workloads
              # Find maximum utilization -> max_load
              # Return user with maximum -> most_loaded
              return user with highest workload
          
          
          def get_overloaded_users(users: list[User], tasks: list[Task], threshold: float) -> list of overloaded users:
              """
              Find users whose utilization exceeds threshold.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of overloaded users
              """
              # Calculate workload for each user -> workloads
              # Filter to those over threshold -> overloaded
              return list of overloaded users
          
          
          def balance_workload(users: list[User], tasks: list[Task], threshold: float) -> list of ReassignmentSuggestion:
              """
              Suggest task reassignments to balance workload.
          
              Args:
                  users: list of User
                  tasks: list of Task
                  threshold: number
          
              Returns:
                  list of ReassignmentSuggestion
              """
              # Calculate workloads for all users -> workloads
              # Find overloaded and underloaded users -> over, under
              # Generate reassignment suggestions -> suggestions
              return list of ReassignmentSuggestion
          
          
          def calculate_workflow_progress(workflow: Workflow) -> float:
              """
              Calculate completion percentage of a workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  (completed / total) * 100
              """
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Workflow has no tasks')
              # Count completed tasks -> completed
              # Count total tasks -> total
              # Calculate percentage -> percent
              return (completed / total) * 100
          
          
          def calculate_remaining_work(tasks: list[Task]) -> total remaining hours:
              """
              Calculate total remaining work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total remaining hours
              """
              # Filter to incomplete tasks -> incomplete
              # Sum PERT estimates -> total_hours
              return total remaining hours
          
          
          def calculate_completed_work(tasks: list[Task]) -> total completed hours:
              """
              Calculate total completed work in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  total completed hours
              """
              # Filter to completed tasks -> completed
              # Sum actual hours -> total_hours
              return total completed hours
          
          
          def calculate_velocity(tasks: list[Task], start_time: float, end_time: float) -> velocity in hours per day:
              """
              Calculate team velocity in hours per day.
          
              Args:
                  tasks: list of Task
                  start_time: number
                  end_time: number
          
              Returns:
                  velocity in hours per day
              """
              if not (end_time > start_time):
                  raise ValueError('End time must be after start time')
              # Calculate completed work in period -> completed_hours
              # Calculate days elapsed -> days
              # Divide hours by days -> velocity
              return velocity in hours per day
          
          
          def estimate_completion_date(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> estimated completion timestamp:
              """
              Estimate when workflow will complete.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  estimated completion timestamp
              """
              if not (velocity_hours_per_day > 0):
                  raise ValueError('Velocity must be positive')
              # Calculate remaining work -> remaining_hours
              # Calculate days needed -> days_needed
              # Add to current time -> completion_date
              return estimated completion timestamp
          
          
          def is_workflow_on_track(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> True if on track, False otherwise:
              """
              Check if workflow is on track to meet deadline.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  True if on track, False otherwise
              """
              # Estimate completion date -> est_completion
              # Compare to deadline -> on_track
              return True if on track, False otherwise
          
          
          def calculate_critical_path_length(tasks: list[Task]) -> critical path length in hours:
              """
              Calculate the length of the critical path in hours.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  critical path length in hours
              """
              # Sort tasks topologically -> sorted_tasks
              # Calculate longest path through graph -> critical_path
              # Sum estimates along path -> total_hours
              return critical path length in hours
          
          
          def calculate_workflow_metrics(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> WorkflowMetrics:
              """
              Calculate comprehensive metrics for a workflow.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  WorkflowMetrics
              """
              # Count tasks by status -> counts
              # Calculate progress percentage -> progress
              # Estimate completion date -> est_completion
              # Determine if on track -> on_track
              # Calculate critical path -> critical_length
              return WorkflowMetrics
          
          
          def create_workflow(id: str, name: str, owner_id: str, timestamp: float) -> new Workflow in draft status:
              """
              Create a new workflow in draft status.
          
              Args:
                  id: string
                  name: string
                  owner_id: string
                  timestamp: number
          
              Returns:
                  new Workflow in draft status
              """
              # Create workflow with draft status -> workflow
              return new Workflow in draft status
          
          
          def add_task_to_workflow(workflow: Workflow, task: Task) -> updated workflow:
              """
              Add a task to a workflow.
          
              Args:
                  workflow: Workflow
                  task: Task
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only add tasks to draft workflows')
              # Append task to workflow tasks -> updated
              return updated workflow
          
          
          def remove_task_from_workflow(workflow: Workflow, task_id: str) -> updated workflow:
              """
              Remove a task from a workflow.
          
              Args:
                  workflow: Workflow
                  task_id: string
          
              Returns:
                  updated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only remove tasks from draft workflows')
              # Filter out task with ID -> updated
              return updated workflow
          
          
          def activate_workflow(workflow: Workflow, timestamp: float) -> activated workflow:
              """
              Activate a draft workflow.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  activated workflow
              """
              if not (workflow.status.value == "draft"):
                  raise ValueError('Can only activate draft workflows')
              if not (len(workflow.tasks) > 0):
                  raise ValueError('Cannot activate empty workflow')
              if not (not detect_circular_dependencies(workflow.tasks)):
                  raise ValueError('Workflow has circular dependencies')
              # Update status to active -> updated
              # Set started_at timestamp -> final
              return activated workflow
          
          
          def pause_workflow(workflow: Workflow) -> paused workflow:
              """
              Pause an active workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  paused workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only pause active workflows')
              # Update status to paused -> updated
              return paused workflow
          
          
          def resume_workflow(workflow: Workflow) -> resumed workflow:
              """
              Resume a paused workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  resumed workflow
              """
              if not (workflow.status.value == "paused"):
                  raise ValueError('Can only resume paused workflows')
              # Update status to active -> updated
              return resumed workflow
          
          
          def all_tasks_terminal(tasks: list[Task]) -> all tasks are completed or cancelled:
              """
              Check if all tasks in a list are terminal.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  all tasks are completed or cancelled
              """
              # Check each task is terminal -> all_done
              return all tasks are completed or cancelled
          
          
          def complete_workflow(workflow: Workflow, timestamp: float) -> completed workflow:
              """
              Mark a workflow as completed.
          
              Args:
                  workflow: Workflow
                  timestamp: number
          
              Returns:
                  completed workflow
              """
              if not (workflow.status.value == "active"):
                  raise ValueError('Can only complete active workflows')
              if not (all_tasks_terminal(workflow.tasks)):
                  raise ValueError('Cannot complete workflow with pending tasks')
              # Update status to completed -> updated
              # Set completed_at timestamp -> final
              return completed workflow
          
          
          def archive_workflow(workflow: Workflow) -> archived workflow:
              """
              Archive a completed workflow.
          
              Args:
                  workflow: Workflow
          
              Returns:
                  archived workflow
              """
              if not (workflow.status.value == "completed"):
                  raise ValueError('Can only archive completed workflows')
              # Update status to archived -> updated
              return archived workflow
          
          
          def filter_tasks_by_status(tasks: list[Task], status: TaskStatus) -> tasks matching status:
              """
              Filter tasks to those matching a status.
          
              Args:
                  tasks: list of Task
                  status: TaskStatus
          
              Returns:
                  tasks matching status
              """
              return tasks matching status
          
          
          def filter_tasks_by_priority(tasks: list[Task], priority: Priority) -> tasks matching priority:
              """
              Filter tasks to those matching a priority.
          
              Args:
                  tasks: list of Task
                  priority: Priority
          
              Returns:
                  tasks matching priority
              """
              return tasks matching priority
          
          
          def filter_tasks_by_assignee(tasks: list[Task], user_id: str) -> tasks assigned to user:
              """
              Filter tasks to those assigned to a user.
          
              Args:
                  tasks: list of Task
                  user_id: string
          
              Returns:
                  tasks assigned to user
              """
              return tasks assigned to user
          
          
          def filter_unassigned_tasks(tasks: list[Task]) -> unassigned tasks:
              """
              Filter to tasks with no assignee.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  unassigned tasks
              """
              # Filter to tasks where assignee_id is None -> unassigned
              return unassigned tasks
          
          
          def filter_overdue_tasks(tasks: list[Task], current_time: float) -> list of overdue tasks:
              """
              Filter tasks that are past their due date.
          
              Args:
                  tasks: list of Task
                  current_time: number
          
              Returns:
                  list of overdue tasks
              """
              # Filter to tasks with due_date set -> with_due
              # Filter to non-terminal past due -> overdue
              return list of overdue tasks
          
          
          def filter_tasks_due_soon(tasks: list[Task], current_time: float, window_hours: float) -> tasks due soon:
              """
              Filter tasks due within a time window.
          
              Args:
                  tasks: list of Task
                  current_time: number
                  window_hours: number
          
              Returns:
                  tasks due soon
              """
              # Calculate deadline threshold -> threshold
              # Filter tasks due before threshold -> due_soon
              return tasks due soon
          
          
          def search_tasks_by_tag(tasks: list[Task], tag: str) -> tasks with matching tag:
              """
              Find tasks that have a specific tag.
          
              Args:
                  tasks: list of Task
                  tag: string
          
              Returns:
                  tasks with matching tag
              """
              # TODO: Return tasks with fields: matching tag
              return {}
          
          
          def search_tasks_by_title(tasks: list[Task], search_term: str) -> matching tasks:
              """
              Find tasks with title containing search term.
          
              Args:
                  tasks: list of Task
                  search_term: string
          
              Returns:
                  matching tasks
              """
              # Filter tasks where title contains term -> matching
              return matching tasks
          
          
          def sort_tasks_by_priority(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by priority highest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort using priority weight as key -> sorted_tasks
              return sorted list of tasks
          
          
          def sort_tasks_by_due_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by due date earliest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Separate tasks with and without due dates -> with_due, no_due
              # Sort tasks with due dates -> sorted_due
              # Append tasks without due dates -> combined
              return sorted list of tasks
          
          
          def sort_tasks_by_created_date(tasks: list[Task]) -> sorted list of tasks:
              """
              Sort tasks by creation date oldest first.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  sorted list of tasks
              """
              # Sort by created_at ascending -> sorted_tasks
              return sorted list of tasks
          
          
          def generate_status_summary(tasks: list[Task]) -> StatusCounts:
              """
              Generate a summary of task counts by status.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  StatusCounts
              """
              # Get status counts -> counts
              return StatusCounts
          
          
          def generate_priority_summary(tasks: list[Task]) -> PriorityCounts:
              """
              Generate a summary of task counts by priority.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  PriorityCounts
              """
              # Count critical tasks -> critical
              # Count high tasks -> high
              # Count medium tasks -> medium
              # Count low tasks -> low
              return PriorityCounts
          
          
          def calculate_average_completion_time(tasks: list[Task]) -> average completion time in hours:
              """
              Calculate average time to complete tasks.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  average completion time in hours
              """
              # Filter to completed tasks with timestamps -> completed
              # Calculate duration for each -> durations
              # Average the durations -> avg_time
              return average completion time in hours
          
          
          def calculate_estimation_accuracy(tasks: list[Task]) -> accuracy percentage:
              """
              Calculate how accurate estimates were vs actual.
          
              Args:
                  tasks: list of Task
          
              Returns:
                  accuracy percentage
              """
              # Filter to tasks with estimates and actuals -> with_data
              # Calculate estimate vs actual ratio for each -> ratios
              # Average the ratios -> accuracy
              return accuracy percentage
          
          
          def generate_user_performance_report(user: User, tasks: list[Task], period_start: float, period_end: float) -> performance report for user:
              """
              Generate performance metrics for a user.
          
              Args:
                  user: User
                  tasks: list of Task
                  period_start: number
                  period_end: number
          
              Returns:
                  performance report for user
              """
              # Get user tasks in period -> user_tasks
              # Calculate completed count -> completed
              # Calculate average completion time -> avg_time
              # Calculate estimation accuracy -> accuracy
              return performance report for user
          
          
          def generate_workflow_summary(workflow: Workflow, current_time: float, velocity_hours_per_day: float) -> workflow summary:
              """
              Generate executive summary of workflow status.
          
              Args:
                  workflow: Workflow
                  current_time: number
                  velocity_hours_per_day: number
          
              Returns:
                  workflow summary
              """
              # Calculate metrics -> metrics
              # Generate summary text -> summary
              return workflow summary

targets:
  python:
    file: F:\Github\mnehmos.nls.lang\examples\workflow_engine.py
    hash: sha256:85eba073100d
    lines: 1318