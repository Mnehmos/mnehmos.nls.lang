"""
NLS Lockfile - Determinism guarantees for NLS compilation

Generates and verifies .nl.lock files to ensure reproducible builds.
"""

import hashlib
import json
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

from . import __version__
from .schema import NLFile, ANLU


@dataclass
class ANLULock:
    """Lock entry for a single ANLU"""
    source_hash: str
    output_hash: str
    output_lines: int


@dataclass
class ModuleLock:
    """Lock entry for a module"""
    source_hash: str
    anlus: dict[str, ANLULock] = field(default_factory=dict)


@dataclass
class TargetLock:
    """Lock entry for a generated target file"""
    file: str
    hash: str
    lines: int


@dataclass
class Lockfile:
    """Complete lockfile structure"""
    schema_version: int = 1
    generated_at: str = ""
    compiler_version: str = __version__
    llm_backend: str = "mock"
    
    modules: dict[str, ModuleLock] = field(default_factory=dict)
    targets: dict[str, TargetLock] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.generated_at:
            self.generated_at = datetime.now(timezone.utc).isoformat()


def hash_content(content: str) -> str:
    """Generate SHA256 hash of content"""
    return f"sha256:{hashlib.sha256(content.encode('utf-8')).hexdigest()[:12]}"


def hash_anlu(anlu: ANLU) -> str:
    """Generate deterministic hash of an ANLU"""
    # Create canonical representation
    canonical = f"{anlu.identifier}|{anlu.purpose}|{anlu.returns}"
    canonical += "|" + ",".join(f"{i.name}:{i.type}" for i in anlu.inputs)
    canonical += "|" + ",".join(anlu.depends)
    return hash_content(canonical)


def generate_lockfile(
    nl_file: NLFile,
    generated_code: str,
    output_path: str,
    llm_backend: str = "mock"
) -> Lockfile:
    """
    Generate a lockfile for a compilation.
    
    Args:
        nl_file: The parsed NLFile
        generated_code: The generated Python code
        output_path: Path to the generated file
        llm_backend: Name of LLM backend used
    
    Returns:
        Lockfile object
    """
    lockfile = Lockfile(llm_backend=llm_backend)
    
    # Create module lock
    module_lock = ModuleLock(
        source_hash=hash_content(Path(nl_file.source_path).read_text() if nl_file.source_path else "")
    )
    
    # Lock each ANLU
    for anlu in nl_file.anlus:
        # Find this ANLU's generated code (rough extraction)
        func_name = anlu.python_name
        anlu_code = ""  # Would need to extract from generated_code
        
        module_lock.anlus[anlu.identifier] = ANLULock(
            source_hash=hash_anlu(anlu),
            output_hash=hash_content(anlu_code or func_name),
            output_lines=0  # Would count actual lines
        )
    
    lockfile.modules[nl_file.module.name] = module_lock
    
    # Lock target
    output_lines = generated_code.count("\n") + 1
    lockfile.targets["python"] = TargetLock(
        file=output_path,
        hash=hash_content(generated_code),
        lines=output_lines
    )
    
    return lockfile


def write_lockfile(lockfile: Lockfile, path: Path) -> None:
    """Write lockfile to disk as YAML-like format"""
    lines = [
        "# DO NOT EDIT - Generated by nlsc",
        f"# {lockfile.generated_at}",
        "",
        f"schema_version: {lockfile.schema_version}",
        f"generated_at: {lockfile.generated_at}",
        f"compiler_version: {lockfile.compiler_version}",
        f"llm_backend: {lockfile.llm_backend}",
        "",
        "modules:"
    ]
    
    for mod_name, mod_lock in lockfile.modules.items():
        lines.append(f"  {mod_name}:")
        lines.append(f"    source_hash: {mod_lock.source_hash}")
        lines.append("    anlus:")
        for anlu_id, anlu_lock in mod_lock.anlus.items():
            lines.append(f"      {anlu_id}:")
            lines.append(f"        source_hash: {anlu_lock.source_hash}")
            lines.append(f"        output_hash: {anlu_lock.output_hash}")
            lines.append(f"        output_lines: {anlu_lock.output_lines}")
    
    lines.append("")
    lines.append("targets:")
    for target_name, target_lock in lockfile.targets.items():
        lines.append(f"  {target_name}:")
        lines.append(f"    file: {target_lock.file}")
        lines.append(f"    hash: {target_lock.hash}")
        lines.append(f"    lines: {target_lock.lines}")
    
    path.write_text("\n".join(lines), encoding="utf-8")


def read_lockfile(path: Path) -> Optional[Lockfile]:
    """Read an existing lockfile (simple YAML-like parser)"""
    if not path.exists():
        return None

    content = path.read_text(encoding="utf-8")
    lockfile = Lockfile()
    lockfile.anlus = {}  # Simple dict for ANLU hashes

    current_module = None
    current_anlu = None

    for line in content.split("\n"):
        line = line.rstrip()

        # Skip comments and empty lines
        if line.startswith("#") or not line.strip():
            continue

        # Parse key-value pairs
        if ":" in line:
            # Count indentation
            indent = len(line) - len(line.lstrip())
            key, _, value = line.strip().partition(":")
            value = value.strip()

            if indent == 0:
                # Top-level
                if key == "schema_version":
                    lockfile.schema_version = int(value) if value else 1
                elif key == "generated_at":
                    lockfile.generated_at = value
                elif key == "compiler_version":
                    lockfile.compiler_version = value
                elif key == "llm_backend":
                    lockfile.llm_backend = value

            elif indent == 2 and key == "modules":
                pass  # Section header

            elif indent == 4 and current_module is None:
                # Module name
                current_module = key

            elif indent == 6 and key == "anlus":
                pass  # ANLUs section header

            elif indent == 8 and current_module:
                # ANLU ID
                current_anlu = key
                if current_anlu not in lockfile.anlus:
                    lockfile.anlus[current_anlu] = {}

            elif indent == 10 and current_anlu:
                # ANLU property
                lockfile.anlus[current_anlu][key] = value

    return lockfile


def verify_lockfile(lockfile: Lockfile, nl_file: NLFile) -> list[str]:
    """
    Verify that a lockfile matches current sources.
    
    Returns:
        List of verification errors (empty if valid)
    """
    errors = []
    
    mod_lock = lockfile.modules.get(nl_file.module.name)
    if not mod_lock:
        errors.append(f"Module {nl_file.module.name} not in lockfile")
        return errors
    
    for anlu in nl_file.anlus:
        anlu_lock = mod_lock.anlus.get(anlu.identifier)
        if not anlu_lock:
            errors.append(f"ANLU {anlu.identifier} not in lockfile")
            continue
        
        current_hash = hash_anlu(anlu)
        if current_hash != anlu_lock.source_hash:
            errors.append(f"ANLU {anlu.identifier} has changed since lock")
    
    return errors
