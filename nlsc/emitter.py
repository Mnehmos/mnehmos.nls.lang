"""
NLS Emitter - Generate Python code from ANLUs

Uses mock/template-based generation for V0.
LLM integration can be added as a separate backend.
"""

import re
from typing import Optional

from .schema import ANLU, NLFile


class EmitError(Exception):
    """Error during code emission"""
    pass


def emit_function_signature(anlu: ANLU) -> str:
    """Generate Python function signature from ANLU"""
    # Build parameter list
    params = []
    for inp in anlu.inputs:
        param = inp.name
        py_type = inp.to_python_type()
        params.append(f"{param}: {py_type}")
    
    param_str = ", ".join(params)
    return_type = anlu.to_python_return_type()
    
    return f"def {anlu.python_name}({param_str}) -> {return_type}:"


def emit_docstring(anlu: ANLU) -> str:
    """Generate docstring from ANLU purpose and inputs"""
    lines = [f'    """', f"    {anlu.purpose}"]
    
    if anlu.inputs:
        lines.append("")
        lines.append("    Args:")
        for inp in anlu.inputs:
            desc = inp.description or inp.type
            lines.append(f"        {inp.name}: {desc}")
    
    if anlu.returns:
        lines.append("")
        lines.append("    Returns:")
        lines.append(f"        {anlu.returns}")
    
    lines.append('    """')
    return "\n".join(lines)


def emit_body_mock(anlu: ANLU) -> str:
    """
    Generate function body using mock/template approach.
    
    Handles simple patterns deterministically:
    - RETURNS: a + b -> return a + b
    - RETURNS: a × b -> return a * b
    - RETURNS: a - b -> return a - b
    - RETURNS: a / b -> return a / b
    """
    returns = anlu.returns.strip()
    
    # Direct expression returns (a + b, a × b, etc.)
    # Replace math symbols
    expr = returns.replace("×", "*").replace("÷", "/")
    
    # Check if it's a simple expression with known operators
    if re.match(r"^[a-z_][a-z0-9_]*\s*[\+\-\*\/]\s*[a-z_][a-z0-9_]*$", expr, re.IGNORECASE):
        return f"    return {expr}"
    
    # Check for function-like returns: "result with field1, field2"
    if " with " in returns.lower():
        # For now, just return a dict
        parts = returns.split(" with ", 1)
        return f'    # TODO: Return {parts[0]} with fields: {parts[1]}\n    return {{}}'
    
    # If logic steps are provided, generate from those
    if anlu.logic:
        lines = ["    # Generated from LOGIC steps:"]
        for i, step in enumerate(anlu.logic, 1):
            lines.append(f"    # {i}. {step}")
        lines.append(f"    # TODO: Implement logic")
        lines.append(f"    raise NotImplementedError('{anlu.identifier}')")
        return "\n".join(lines)
    
    # If guards are provided, generate guard checks
    if anlu.guards:
        lines = []
        for guard in anlu.guards:
            lines.append(f"    # Guard: {guard.condition}")
            if guard.error_message:
                lines.append(f'    # → {guard.error_type or "Error"}({guard.error_message})')
        lines.append(f"    raise NotImplementedError('{anlu.identifier}')")
        return "\n".join(lines)
    
    # Fallback: return the expression as-is if it looks like valid Python
    if expr and not " " in expr:
        return f"    return {expr}"
    
    return f"    raise NotImplementedError('{anlu.identifier}')"


def emit_anlu(anlu: ANLU, mode: str = "mock") -> str:
    """
    Emit Python code for a single ANLU.
    
    Args:
        anlu: The ANLU to emit
        mode: "mock" for template-based, "llm" for LLM-based (future)
    
    Returns:
        Python function as a string
    """
    parts = [
        emit_function_signature(anlu),
        emit_docstring(anlu),
        emit_body_mock(anlu)
    ]
    
    return "\n".join(parts)


def emit_python(nl_file: NLFile, mode: str = "mock") -> str:
    """
    Emit complete Python module from NLFile.
    
    Args:
        nl_file: Parsed NLFile
        mode: Emission mode ("mock" or "llm")
    
    Returns:
        Complete Python source code
    """
    lines = [
        f'"""',
        f"Generated by nlsc from {nl_file.source_path or 'unknown'}",
        f"Module: {nl_file.module.name}",
        f'"""',
        ""
    ]
    
    # Add imports
    if nl_file.module.imports:
        for imp in nl_file.module.imports:
            lines.append(f"import {imp.strip()}")
        lines.append("")
    
    # Add type imports if needed
    has_any = any(
        "any" in (inp.type for inp in anlu.inputs)
        for anlu in nl_file.anlus
    )
    if has_any:
        lines.insert(4, "from typing import Any")
    
    # Emit each ANLU in dependency order
    ordered = nl_file.dependency_order()
    for anlu in ordered:
        lines.append("")
        lines.append(emit_anlu(anlu, mode))
        lines.append("")
    
    # Add any literal blocks
    if nl_file.literals:
        lines.append("")
        lines.append("# --- Literal blocks ---")
        for literal in nl_file.literals:
            lines.append(literal)
    
    return "\n".join(lines)


def emit_tests(nl_file: NLFile) -> Optional[str]:
    """
    Emit pytest tests from @test blocks.
    
    Returns:
        Python test file content, or None if no tests
    """
    if not nl_file.tests:
        return None
    
    module_name = nl_file.module.name.replace("-", "_")
    
    lines = [
        f'"""',
        f"Tests generated by nlsc from {nl_file.source_path or 'unknown'}",
        f'"""',
        "",
        "import pytest",
        f"from .{module_name} import *",
        ""
    ]
    
    for test_suite in nl_file.tests:
        lines.append("")
        lines.append(f"class Test{test_suite.anlu_id.replace('-', '_').title()}:")
        
        for i, case in enumerate(test_suite.cases):
            lines.append(f"    def test_case_{i + 1}(self):")
            lines.append(f"        assert {case.expression} == {case.expected}")
            lines.append("")
    
    return "\n".join(lines)
